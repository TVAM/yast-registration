/**
 * File:    modules/OnlineUpdateConfiguration.ycp
 * Package: Installation
 * Summary: Registration related stuff
 * Authors: J. Daniel Schmidt <jdsn@suse.de>
 *
 * $Id: OnlineUpdateConfiguration.ycp 1 2008-09-10 09:45:05Z jdsn $
 */

{

module "OnlineUpdateConfiguration";

import "Package";
import "URL";

textdomain "registration";



global boolean enableAOU = false;
global boolean skipInteractivePatches = true;
global symbol  updateInterval = `weekly;
global boolean OUCmodified = false;


string onlineUpdateScript = "/usr/lib/YaST2/bin/online_update";

string cronFileName    = "opensuse.org-online_update";
string cronMonthlyFile = "/etc/cron.monthly/" + cronFileName;
string cronWeeklyFile  = "/etc/cron.weekly/"  + cronFileName;
string cronDailyFile   = "/etc/cron.daily/"   + cronFileName;

global string currentUpdateRepo = "";
global string defaultUpdateRepo = "";
global list<string> allUpdateRepos  = [];
global string defaultRegistrationURL = "";

// cache the base product details
map<string, any> baseProductDetail = $[];
map<symbol, string> Intervals = $[  `daily  : "daily",
                                    `weekly : "weekly",
                                    `monthly: "monthly" ];

/*
 * fetchBaseProductDetails
 * get the details of the base product to find its default update Source or registration server
 * the found base product will be saved in the cache variable  baseProductDetail
 *
 * @return true if a base product is found, else false
 */
boolean fetchBaseProductDetails()
{
    y2milestone("Searching base product details.");

    // fetch product details about installed products
    list<map <string, any> > productDetail = (list<map <string, any> >) Pkg::ResolvableProperties( "", `product, "" );
    baseProductDetail = $[];

//FIXME START
//FIXME: 1) pkg-bindings return only addon products for openSUSE (bnc#449844)
//FIXME: 2) the product definition does not contain update URLS (bnc#449842)
//FIXME: If either of these remain unfixed the following two lines need to be uncommented,
//FIXME: otherwise restoring of the default update repo is only possible via NCC registration
/*
productDetail[0, "category"]="base";
productDetail[0, "update_urls"] = ["http://download.opensuse.org/update/11.1/"];
*/
//FIXME END

    y2debug("All installed products are: %1", productDetail);
    y2debug("Now looking for the base product");

    // filter the map to find the one any only base product
    productDetail = filter( map<string, any> oneProduct, productDetail, {
        return oneProduct["category"]:"unknown" == "base";
    });

    y2debug("All installed base products are: %1", productDetail);
    if ( size(productDetail) < 1 )
    {
        y2error("Could not find any base product.");
        baseProductDetail = $[];
        return false;
    }
    else if ( size(productDetail) > 1 )
    {
        y2error("Found more than one base product. This is a severe problem as there may only be one base product.");
        y2error("This system seems to be broken. However the first found product will be used.");
    }
    else
        y2milestone("Found exactly one base product.");

    baseProductDetail = productDetail[0]:$[];
    y2milestone("Found a base product: %1", baseProductDetail);

    return true;
}

/*
 * compareUpdateURLs
 * compare two URLs - only the scheme, hostname and path will be compared, a trailing slash will be ignored
 * @return true if urls match
 */
global boolean compareUpdateURLs(string url1, string url2, boolean allowEmpty)
{
    y2debug("Comparing two urls.");
    if ( url1 == "" &&  url2 == "" && ! allowEmpty )
    {
        return false;
    }

    map url1map = URL::Parse(url1);
    map url2map = URL::Parse(url2);

    // removing trailing slash
    if ( regexpmatch( url1map["path"]:"", "/$" ) )
        url1map["path"]   = regexpsub(url1map["path"]:"", "(.*)/$", "\\1");
    if ( regexpmatch( url2map["path"]:"", "/$" ) )
        url2map["path"]   = regexpsub(url2map["path"]:"", "(.*)/$", "\\1");

    if ( tolower(url1map["scheme"]:"X") ==  tolower(url2map["scheme"]:"Y") &&
         tolower(url1map["host"]:"X")   ==  tolower(url2map["host"]:"Y")   &&
         url1map["path"]:"X"   ==  url2map["path"]:"Y"                         )
    {
        return true;
    }

    return false;
}


/*
 * fetchBaseProductURLs
 * fetches the default update repo URL and the registration server URL and saves them in the global variables
 *
 * @return true if successfull
 */
global boolean fetchBaseProductURLs()
{
    string defUp = "";
    string defReg = "";

    if ( defaultUpdateRepo == nil ||
         defaultUpdateRepo == ""     )
    {
        y2milestone("Looking for default update repo.");
        fetchBaseProductDetails();
    }

    if ( baseProductDetail == nil ||
         baseProductDetail == $[]    )
    {
        y2error("Could not find any details about the base product and thus no default update repo.");
        return false;
    }
    else
    { // base product details available

        // handle default update repository
        list<string> updateURLs = (list<string>) baseProductDetail["update_urls"]:[];
        allUpdateRepos = updateURLs;

        if ( size(updateURLs) < 1 )
        {
            y2error("Base product does not provide a default update repository.");
            defUp = "";
        }
        else if ( size(updateURLs) == 1  )
        {
            y2milestone("Found exactly one default update URL.");
            defUp = updateURLs[0]:"";
        }
        else
        {
            y2milestone("Found multiple default update repositories. Will pick one as default.");
            // first looking for opensuse.org update repos
            list<string> filteredUpdateURLs = filter( string oneURL,  updateURLs, {
                return regexpmatch( oneURL, "\.opensuse\.org");
            });

            if ( size(filteredUpdateURLs) < 1 )
            { // no opensuse.org update repo found - looking for novell.com repos
                filteredUpdateURLs = filter( string oneURL,  updateURLs, {
                    return regexpmatch( oneURL, "\.novell\.com");
                });
            }

            if ( size(filteredUpdateURLs) < 1 )
            {
                // no opensuse.org or novell.com update repo found
                y2milestone("Will use the first found update repository.");
                defUp = updateURLs[0]:"";
            }
            else if ( size(filteredUpdateURLs) == 1 )
            {
                y2milestone("Will use default opensuse.org resp. novell.com update repository.");
                defUp = filteredUpdateURLs[0]:"";
            }
            else
            {
                y2milestone("After filtering still multiple cadidates remain as default update repository.");
                y2milestone("Will now use the first found update repository.");
                defUp = filteredUpdateURLs[0]:"";
            }
        }

        // handle default registration server
        list<string> registerURLs = (list<string>) baseProductDetail["register_urls"]:[];
        if ( size(registerURLs) < 1 )
        {
            y2error("No default registration URL found.");
            defReg = "";
        }
        else if ( size(registerURLs) == 1  )
        {
            y2milestone("Found exactly one registration URL.");
            defReg = registerURLs[0]:"";
        }
        else
        {
            y2milestone("Found multiple registration URLs. Will pick one as default.");
            // first looking for novell.com registration URLs
            list<string> filteredRegisterURLs = filter( string oneURL,  registerURLs, {
                return regexpmatch( oneURL, "\.novell\.com");
            });

            if ( size(filteredRegisterURLs) < 1 )
            { // no novell.com registration URL found - looking for opensuse.org URL
                filteredRegisterURLs = filter( string oneURL,  registerURLs, {
                    return regexpmatch( oneURL, "\.opensuse\.org");
                });
            }

            if ( size(filteredRegisterURLs) < 1 )
            {
                // no opensuse.org or novell.com update repo found
                y2milestone("Will use the first found registration URL.");
                defReg = registerURLs[0]:"";
            }
            else if ( size(filteredRegisterURLs) == 1 )
            {
                y2milestone("Will use default novell.com resp. opensuse.org registration URL.");
                defReg = filteredRegisterURLs[0]:"";
            }
            else
            {
                y2milestone("After filtering still multiple cadidates remain as default registration URL.");
                y2milestone("Will now use the first found registration URL.");
                defReg = filteredRegisterURLs[0]:"";
            }
        }
    }

    defaultUpdateRepo = defUp;
    defaultRegistrationURL = defReg;
    map logUpdateRepoMap = URL::Parse(defaultUpdateRepo);
    if ( logUpdateRepoMap["pass"]:""  != nil  && 
         logUpdateRepoMap["pass"]:""  != ""     )
    { logUpdateRepoMap["pass"] = "--a-password-is-set--"; }
    string logUpdateRepo = URL::Build(logUpdateRepoMap);

    y2milestone("Found default update repository is: %1", logUpdateRepo);
    y2milestone("Using this default registration URL: %1", defaultRegistrationURL);
    y2milestone("This registration URL will not be written to the system. The registration module itself will offer to change the default registration URL. Here the URL is used just to find out if this product can be registered.");

    return true;
}

/*
 * fetchCurrentUpdateRepoURL
 * returns the currentUpdateRepoURL or and updates the global variable that caches this value
 */
global string fetchCurrentUpdateRepoURL()
{
    string curUp = "";

    if ( size(allUpdateRepos) < 1 )
    {
        y2error("No current update repos found to compare the default update repo with.");
        curUp = "";
    }
    else
    {
        list<integer> allCurrentRepos = Pkg::SourceGetCurrent(true);
        if ( size(allCurrentRepos) < 1 )
        {
            y2milestone("No current sources found.");
            curUp = "";
        }
        else
        {
            list<string> foundUpdateRepo = [];

            foreach(integer repoID, allCurrentRepos, {
                string repoURL = Pkg::SourceURL(repoID);

                foreach(string upRepo, allUpdateRepos, {
                    if ( compareUpdateURLs(repoURL, upRepo, false) )
                    {
                        foundUpdateRepo = add( foundUpdateRepo, repoURL );
                    }
                });
            });

            if ( size(foundUpdateRepo) < 1 )
            {
                y2milestone("Could not find any update repo in the system");
            }
            else if ( size(foundUpdateRepo) == 1 )
            {
                y2milestone("Found exactly one update repo.");
                curUp = foundUpdateRepo[0]:"";
                // found an update repo in the system that is provided by the product as well - so it is the default
                defaultUpdateRepo = curUp;
            }
            else
            {
                y2milestone("Found multiple update repos. Will only use the first one.");
                curUp = foundUpdateRepo[0]:"";
                // found an update repo in the system that is provided by the product as well - so it is the default
                defaultUpdateRepo = curUp;
            }
        }
    }

    currentUpdateRepo = curUp;
    y2milestone("Current update repo is: %1", currentUpdateRepo);
    return curUp;
}



global boolean setUpdateRepo(string updateRepo)
{
    y2milestone("User wants to set the default update repo to: %1", updateRepo);

    // create map for new source
    map<string, any> newSrcMap = $[  "enabled"       : true,
                                     "autorefresh"   : true,
                                     "name"          : "Default-Update-Repository",
                                     "alias"         : "Default-Update-Repository",
                                     "base_urls"     : [ updateRepo ],
                                     "priority"      : 20
                                 ];

    y2milestone("Adding new update repository.");
    integer newSrcID = Pkg::RepositoryAdd( newSrcMap );
    if (newSrcID != nil)
    {
        y2milestone("Successfully added the default update repository to the system.");
        currentUpdateRepo = updateRepo;
    }
    else
    {
        y2error("Could not add the default update repository to the system.");
    }

    y2milestone("Saving all source changes to the system.");
    Pkg::SourceSaveAll();

    return true;
}

global string intervalSymbolToString(symbol intervalSym)
{
    return Intervals[intervalSym]:"none";
}

global symbol intervalStringToSymbol(string intervalStr)
{
    symbol result = `none;
    foreach(symbol sym, string str, Intervals, {
        if ( str == intervalStr ) result = sym;
        return;
    } );
    return result;
}

/*
 * remove all online update cronjobs
 *
 */
void removeOnlineUpdateCronjobs()
{
    SCR::Execute(.target.remove, cronMonthlyFile);
    SCR::Execute(.target.remove, cronWeeklyFile);
    SCR::Execute(.target.remove, cronDailyFile);
}

/*
 * setup cronjob for an automatic online update
 * @return true if successful
 * @para smybol for the interval `daily, `weekly, `monthly
 */
global boolean setOnlineUpdateCronjob(symbol interval)
{
    string cronSel = "";
    if      (interval == `monthly)
        cronSel = cronMonthlyFile;
    else if (interval == `weekly)
        cronSel = cronWeeklyFile;
    else if (interval == `daily)
        cronSel = cronDailyFile;

    removeOnlineUpdateCronjobs();

    if ( (boolean)SCR::Execute(.target.symlink, onlineUpdateScript, cronSel) )
    {
        y2milestone("Setting up online update cron job at %1", cronSel);
        return true;
    }
    else
    {
        y2milestone("Could not create online update cron job at %1", cronSel);
        return false;
    }

    return true;
}




/*
 * Read()
 */
global void Read()
{
    // just for documentation: defaultUpdateRepo for 11.1 should be "http://download.opensuse.org/update/11.1/"

    if (fetchBaseProductDetails() )
        y2milestone("Fetched base product detail information");
    else
        y2error("Could not fetch base product details information.");

    // read base URLs from the base product
    fetchBaseProductURLs();
    // this will update the default update repo as well - so do it once here
    string foo = fetchCurrentUpdateRepoURL();

    integer interM = (integer) SCR::Read(.target.size, cronMonthlyFile);
    integer interW = (integer) SCR::Read(.target.size, cronWeeklyFile);
    integer interD = (integer) SCR::Read(.target.size, cronDailyFile);

    if (interD >= 0)
        updateInterval = `daily;
    else if (interW >= 0)
        updateInterval = `weekly;
    else if (interM >= 0)
        updateInterval = `monthly;
    else
        updateInterval = `weekly;

    // enableAOU is not read from sysconfig! this is only to deactivate it temporarily
    // only the fact that a cronjob exists makes this setting true
    enableAOU = ( interD >= 0 || interW >= 0 || interM >= 0  );
    skipInteractivePatches = ( (string)SCR::Read(.sysconfig.automatic_online_update.AOU_SKIP_INTERACTIVE_PATCHES) == "true" ) ? true:false;

}


/*
 * Import()
 */
global boolean Import(map settings)
{
    enableAOU = false;
    skipInteractivePatches = true;
    updateInterval = `weekly;

    enableAOU              = (boolean) settings["enable_automatic_online_update"]:enableAOU;
    skipInteractivePatches = (boolean) settings["skip_interactive_patches"]:skipInteractivePatches;

    string getInterval     = (string) settings["update_interval"]:"";

    if ( enableAOU == nil ) enableAOU = false;
    updateInterval = intervalStringToSymbol(getInterval);
    // fall back to weekly in error case
    if (updateInterval == `none) updateInterval = `weekly;

    return true;
}


/*
 * Write()
 */
global boolean Write()
{
    SCR::Write(.sysconfig.automatic_online_update.AOU_ENABLE_CRONJOB          , (enableAOU              ? "true":"false") );
    SCR::Write(.sysconfig.automatic_online_update.AOU_SKIP_INTERACTIVE_PATCHES, (skipInteractivePatches ? "true":"false") );

    if (enableAOU)
    {
        y2milestone("Enabling automatic online update with interval: %1", updateInterval);
        return setOnlineUpdateCronjob(updateInterval);
    }
    else
    {
        y2milestone("Automatic online update is disabled.");
        removeOnlineUpdateCronjobs();
        return true;
    }

    return true;
}



/**
 * AutoYaST interface function: Export()
 * @return map with the settings
 */
global map Export()
{
    if (!enableAOU)
    {
        return $[];
    }

    return $[
             "enable_automatic_online_update":enableAOU,
             "skip_interactive_patches":skipInteractivePatches,
             "update_interval":intervalSymbolToString(updateInterval)
    ];
}





}
