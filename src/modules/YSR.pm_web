#
# Copyright (c) 2008 SUSE LINUX Products GmbH.  All rights reserved.
#
# Author: Michael Calmer <mc@suse.de>, 2008
# Editor: J. Daniel Schmidt <jdsn@suse.de>, 2008,2009
#
# YSR.pm - interface for YaST to interact with SUSE::SuseRegister
#

package YSR;

use strict;
use SUSE::SuseRegister;
use Data::Dumper;

use YaPI;

our %TYPEINFO;

my $global_ctx = {};


BEGIN { $TYPEINFO{init_ctx} = ["function", "void", [ "map", "string", "any"]]; }
sub init_ctx
{
    my $self = shift;
    my $data = shift;

    if(defined $global_ctx && ref($global_ctx) eq "HASH" && exists $global_ctx->{debug})
    {
        # ctx is initialized; clean it before we re-init it
        $self->del_ctx();
    }

    $global_ctx = SUSE::SuseRegister::init_ctx($data);
}

BEGIN { $TYPEINFO{del_ctx} = ["function", "void"]; }
sub del_ctx
{
    my $self = shift;

    if(defined $global_ctx && ref($global_ctx) eq "HASH" && exists $global_ctx->{debug})
    {
        # only call del_ctx if it is initialized
        SUSE::SuseRegister::del_ctx($global_ctx);
    }

    $global_ctx = {};
}

BEGIN { $TYPEINFO{get_errorcode} = [ "function", "integer"]; }
sub get_errorcode
{
   my $self = shift;

   return $global_ctx->{errorcode};
}

BEGIN { $TYPEINFO{get_errormsg} = [ "function", "string"]; }
sub get_errormsg
{
   my $self = shift;

   return $global_ctx->{errormsg};
}

BEGIN { $TYPEINFO{listParams} = ["function", "string"]; }
sub listParams
{
    my $self = shift;

    return SUSE::SuseRegister::listParams($global_ctx);
}

BEGIN { $TYPEINFO{register} = ["function", "integer"]; }
sub register
{
    my $self = shift;

    my $ret = SUSE::SuseRegister::register($global_ctx);

    return $ret;
}

BEGIN { $TYPEINFO{getTaskList} = ["function", [ "map", "string", "any"] ]; }
sub getTaskList
{
    my $self = shift;

    return SUSE::SuseRegister::getTaskList($global_ctx);
}

BEGIN { $TYPEINFO{get_args} = [ "function", [ "map", "string", ["map", "string", "string"]]]; }
sub get_args
{
   my $self = shift;

   return $global_ctx->{args};
}

BEGIN { $TYPEINFO{set_args} = [ "function", "void", [ "map", "string", ["map", "string", "string"]]]; }
sub set_args
{
   my $self = shift;
   my $args = shift;

   if(defined $args && ref($args) eq "HASH")
   {
       $global_ctx->{args} = $args;
   }
}

BEGIN { $TYPEINFO{set_arg} = [ "function", "void", "string", [ "map", "string", "string"]]; }
sub set_arg
{
   my $self  = shift;
   my $key   = shift;
   my $value = shift;

   if(defined $key && $key ne "")
   {
       if(defined $value && ref($value) eq "HASH" )
       {
           $global_ctx->{args}->{key} = $value;
       }
       else
       {
           delete $global_ctx->{args}->{key};
       }
   }
}

BEGIN { $TYPEINFO{get_manualURL} = [ "function", "string"]; }
sub get_manualURL
{
   my $self = shift;

   return $global_ctx->{registerManuallyURL};
}

BEGIN { $TYPEINFO{get_registerReadableText} = [ "function", "string"]; }
sub get_registerReadableText
{
   my $self = shift;

   return join('', @{$global_ctx->{registerReadableText}});
}

BEGIN { $TYPEINFO{get_registerPrivPol} = [ "function", "string"]; }
sub get_registerPrivPol
{
   my $self = shift;

   return $global_ctx->{registerPrivPol};
}

BEGIN { $TYPEINFO{saveLastZmdConfig} = [ "function", ["list", "any"]]; }
sub saveLastZmdConfig
{
   my $self = shift;

   return SUSE::SuseRegister::saveLastZmdConfig($global_ctx);
}

BEGIN { $TYPEINFO{set_proxy} = ["function", "void", "string", "string"]; }
sub set_proxy
{
    my $self = shift;
    my $http_proxy = shift;
    my $https_proxy = shift;

    if(defined $http_proxy && $http_proxy =~ /^http/)
    {
        $ENV{http_proxy} = $http_proxy;
    }

    if(defined $https_proxy && $https_proxy =~ /^http/)
    {
        $ENV{https_proxy} = $https_proxy;
    }
}


BEGIN { $TYPEINFO{stateless_register} = ["function", [ "map", "string", "any"], ["map", "string", "any"] ]; }
sub stateless_register
{
    my $self  = shift;
    my $args  = shift;

#return { 'msg' => '4711' };

    unless ( defined $args && ref($args) eq "HASH" )
    {
        print "args is not a hash in YSR::statless_register. This is a bug. Please report this error.\n";
        #return { 'error' => 'The call of the registration failed because of missing arguments.' }
        return { 'error' => { 'args' => 'The call of the registration failed because of missing arguments.' } };
    }

#return { 'msg' => '4712' };
    # check if the system is still initialized - otherwise run init_ctx again
    unless ( defined $global_ctx && ref($global_ctx) eq "HASH" && exists $global_ctx->{debug} )
    {
        # not initialized - need to reinitialize

#return { 'msg' => '4713' };
        # 1. proxy
        if ( exists $args->{'proxy'} && ref($args->{'proxy'}) eq "HASH" )
        {
            my $http  = $args->{'proxy'}{'http_proxy'}  || undef;
            my $https = $args->{'proxy'}{'https_proxy'} || undef;
            $self->set_proxy($http, $https);
        }

#return { 'msg' => '4714' };
        # 2. registration context
        if ( exists $args->{'ctx'} && $args->{'ctx'} eq "HASH" )
        {
            $self->init_ctx($args->{'ctx'});
            my $init_err = $self->get_errorcode();

            unless ($init_err == 0)
            {
                # init failed
                return { 'error' => { 'init' => 'The initialization of the registration failed.' }  };
            }
        }
        else
        {
#return { 'msg' => '4715' };
            # context is broken - return error message
            return { 'error' => { 'ctx' => 'The context for the registration is invalid.' }  };
        }
    }

    return { 'success' => { 'msg' => 'This is the return string.' } };

}


BEGIN { $TYPEINFO{get_registrationConfig} = ["function", [ "map", "string", "any"] ]; }
sub get_registrationDetails
{
    my $self = shift;
    my $SRconf = '/etc/suseRegister.conf'
    my $SRcert = '/etc/ssl/certs/registration-server.pem'

    my $url = undef;
    my $cert = undef;

    if ( -e $SRconf )
    {
        open(CNF, "< $SRconf") || $url = undef;
        while(<CNF>)
        {
            next if($_ =~ /^\s*#/);

            if($_ =~ /^url\s*=\s*(\S*)\s*/ && defined $1 && $1 ne '')
            {  $url = $1;  }
        }
        close CNF;
    }

    if ( -e $SRcert )
    {
        my $separator = $/;
        local $/ = undef;
        open(CERT, "< $SRcert") || $cert = undef;
        $cert = <CERT>;
        close CERT;
        $/ = $separator;
    }

    return { "url" => $url,
             "certificate" => $cert };
}


BEGIN { $TYPEINFO{set_registrationConfig} = ["function", "void", [ "map", "string", "any"] ]; }
sub set_registrationConfig
{
    my $self = shift;
    # TODO: write the config and write the certificate file

    return { "url" => "foobar",
             "certificate" => "barfoo"  };
}


1;

#############################################################################
#############################################################################
#
# internal functions that should not be used directly by YaST (to prevent zypp deadlocks)
# they are here for documentation purposes or future use
#

# BEGIN { $TYPEINFO{get_ctx} = ["function", [ "map", "string", "any"]]; }
# sub get_ctx
# {
#    my $self = shift;

#    return $global_ctx;
# }

# BEGIN { $TYPEINFO{manageUpdateSources} = ["function", "void", [ "map", "string", "any"] ]; }
# sub manageUpdateSources
# {
#     my $self = shift;

#     return SUSE::SuseRegister::manageUpdateSources($global_ctx);
# }


# BEGIN { $TYPEINFO{addService} = ["function", ["list", "any"], [ "map", "string", "any"], [ "map", "string", "any"]]; }
# sub addService
# {
#     my $self = shift;
#     $global_ctx     = shift;
#     my $service = shift || undef;

#     return SUSE::SuseRegister::addService($global_ctx, $service);
# }


# BEGIN { $TYPEINFO{enableCatalog} = ["function", ["list", "any"], [ "map", "string", "any"], "string", [ "map", "string", "string"]]; }
# sub enableCatalog
# {
#     my $self = shift;
#     $global_ctx     = shift;
#     my $name    = shift || undef;
#     my $catalog = shift || undef;

#     return SUSE::SuseRegister::enableCatalog($global_ctx, $name, $catalog);
# }

# BEGIN { $TYPEINFO{deleteService} = ["function", ["list", "any"], [ "map", "string", "any"], [ "map", "string", "any"]]; }
# sub deleteService
# {
#     my $self = shift;
#     $global_ctx = shift;
#     my $service = shift || undef;

#     return SUSE::SuseRegister::deleteService($global_ctx, $service);
# }

# BEGIN { $TYPEINFO{disableCatalog} = ["function", ["list", "any"], [ "map", "string", "any"], "string", [ "map", "string", "string"]]; }
# sub disableCatalog
# {
#     my $self = shift;
#     $global_ctx     = shift;
#     my $name    = shift || undef;
#     my $catalog = shift || undef;

#     return SUSE::SuseRegister::disableCatalog($global_ctx, $name, $catalog);
# }

