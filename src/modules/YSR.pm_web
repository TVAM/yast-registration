#
# Copyright (c) 2008 SUSE LINUX Products GmbH.  All rights reserved.
#
# Author: Michael Calmer <mc@suse.de>, 2008
# Editor: J. Daniel Schmidt <jdsn@suse.de>, 2008,2009
#
# YSR.pm - interface for YaST to interact with SUSE::SuseRegister
#

package YSR;

use strict;
use SUSE::SuseRegister;
use Data::Dumper;

use YaPI;

our %TYPEINFO;

my $global_ctx = {};


BEGIN { $TYPEINFO{init_ctx} = ["function", "void", [ "map", "string", "any"]]; }
sub init_ctx
{
    my $self = shift;
    my $data = shift;

    if(defined $global_ctx && ref($global_ctx) eq "HASH" && exists $global_ctx->{debug})
    {
        # ctx is initialized; clean it before we re-init it
        $self->del_ctx();
    }

    $global_ctx = SUSE::SuseRegister::init_ctx($data);
}

BEGIN { $TYPEINFO{del_ctx} = ["function", "void"]; }
sub del_ctx
{
    my $self = shift;

    if(defined $global_ctx && ref($global_ctx) eq "HASH" && exists $global_ctx->{debug})
    {
        # only call del_ctx if it is initialized
        SUSE::SuseRegister::del_ctx($global_ctx);
    }

    $global_ctx = {};
}

BEGIN { $TYPEINFO{get_errorcode} = [ "function", "integer"]; }
sub get_errorcode
{
   my $self = shift;

   return $global_ctx->{errorcode};
}

BEGIN { $TYPEINFO{get_errormsg} = [ "function", "string"]; }
sub get_errormsg
{
   my $self = shift;

   return $global_ctx->{errormsg};
}

BEGIN { $TYPEINFO{listParams} = ["function", "string"]; }
sub listParams
{
    my $self = shift;

    return SUSE::SuseRegister::listParams($global_ctx);
}

BEGIN { $TYPEINFO{register} = ["function", "integer"]; }
sub register
{
    my $self = shift;

    my $ret = SUSE::SuseRegister::register($global_ctx);

    return $ret;
}

BEGIN { $TYPEINFO{getTaskList} = ["function", [ "map", "string", "any"] ]; }
sub getTaskList
{
    my $self = shift;

    return SUSE::SuseRegister::getTaskList($global_ctx);
}

BEGIN { $TYPEINFO{get_args} = [ "function", [ "map", "string", ["map", "string", "string"]]]; }
sub get_args
{
   my $self = shift;

   return $global_ctx->{args};
}

BEGIN { $TYPEINFO{set_args} = [ "function", "void", [ "map", "string", ["map", "string", "string"]]]; }
sub set_args
{
   my $self = shift;
   my $args = shift;

   if(defined $args && ref($args) eq "HASH")
   {
       $global_ctx->{args} = $args;
   }
}

BEGIN { $TYPEINFO{set_arg} = [ "function", "void", "string", [ "map", "string", "string"]]; }
sub set_arg
{
   my $self  = shift;
   my $key   = shift;
   my $value = shift;

   if(defined $key && $key ne "")
   {
       if(defined $value && ref($value) eq "HASH" )
       {
           $global_ctx->{args}->{key} = $value;
       }
       else
       {
           delete $global_ctx->{args}->{key};
       }
   }
}

BEGIN { $TYPEINFO{get_manualURL} = [ "function", "string"]; }
sub get_manualURL
{
   my $self = shift;

   return $global_ctx->{registerManuallyURL};
}

BEGIN { $TYPEINFO{get_registerReadableText} = [ "function", "string"]; }
sub get_registerReadableText
{
   my $self = shift;

   return join('', @{$global_ctx->{registerReadableText}});
}

BEGIN { $TYPEINFO{get_registerPrivPol} = [ "function", "string"]; }
sub get_registerPrivPol
{
   my $self = shift;

   return $global_ctx->{registerPrivPol};
}

BEGIN { $TYPEINFO{saveLastZmdConfig} = [ "function", ["list", "any"]]; }
sub saveLastZmdConfig
{
   my $self = shift;

   return SUSE::SuseRegister::saveLastZmdConfig($global_ctx);
}

BEGIN { $TYPEINFO{set_proxy} = ["function", "void", "string", "string"]; }
sub set_proxy
{
    my $self = shift;
    my $http_proxy = shift;
    my $https_proxy = shift;

    if(defined $http_proxy && $http_proxy =~ /^http/)
    {
        $ENV{http_proxy} = $http_proxy;
    }

    if(defined $https_proxy && $https_proxy =~ /^http/)
    {
        $ENV{https_proxy} = $https_proxy;
    }
}


BEGIN { $TYPEINFO{statelessregister} = ["function", [ "map", "string", "any"], ["map", "string", "any"], ["map", "string", "any"]]; }
sub statelessregister
{
    my $self  = shift;
    my $ctx = shift;
    my $arguments = shift;

    unless ( defined $ctx && ref($ctx) eq "HASH" )
    {
        return { 'error' => {  'ctx' => 'The context is missing or invalid.' } };
    }

    # check if the system is still initialized - otherwise run init_ctx again
    unless ( defined $global_ctx && ref($global_ctx) eq "HASH" && exists $global_ctx->{debug} )
    {
        # not initialized - need to reinitialize

        # 1. proxy
        if ( exists $ctx->{'proxy'} && ref($ctx->{'proxy'}) eq "HASH" )
        {
            my $http  = $ctx->{'proxy'}{'http_proxy'}  || undef;
            my $https = $ctx->{'proxy'}{'https_proxy'} || undef;
            $self->set_proxy($http, $https);
        }

        # 2. registration context
        $self->init_ctx($ctx);
        my $init_err = $self->get_errorcode();

        unless ($init_err == 0)
        {
            # init failed
            return { 'error' => { 'init' => 'The initialization of the registration failed.'
                                 ,'errorcode' => $init_err
                   }  };
        }
    }

    # set arguments
    $self->set_args($arguments);

    # run registration
    my $exitcode = $self->register();
    my $errorcode = $self->get_errorcode();
    my $readabletext = $self->get_registerReadableText();
    my $tasklist = $exitcode == 0 ? $self->getTaskList() : '';


    return { 'success' => {  'msg'          => 'Successfully ran registration.'
                            ,'exitcode'     => $exitcode
                            ,'errorcode'    => $errorcode
                            ,'readabletext' => $readabletext
                            ,'tasklist'     => $tasklist
           } };
}


BEGIN { $TYPEINFO{getregistrationconfig} = ["function", [ "map", "string", "any"] ]; }
sub getregistrationconfig
{
    my $self = shift;
    my $SRconf = '/etc/suseRegister.conf';
    my $SRcert = '/etc/ssl/certs/registration-server.pem';
    my $SRcredentials = '/etc/zypp/credentials.d/NCCcredentials';

    my $url = undef;
    my $cert = undef;
    my $guid = undef;

    # read the registration server url
    if ( -e $SRconf )
    {
        if (open(CNF, "< $SRconf") )
        {
            while(<CNF>)
            {
                next if($_ =~ /^\s*#/);

                if($_ =~ /^url\s*=\s*(\S*)\s*/ && defined $1 && $1 ne '')
                {  $url = $1;  }
            }
            close CNF;
        }
    }

    #read the registration server ca certificate file
    if ( -e $SRcert )
    {
        my $separator = $/;
        local $/ = undef;
        if ( open(CERT, "< $SRcert") )
        {
            $cert = <CERT>;
            close CERT;
        }
        $/ = $separator;
    }

    # read the guid
    if (-e $SRcredentials)
        {
        if (open(CRED, "< $SRcredentials") )
        {
            while(<CRED>)
            {
                next if($_ =~ /^\s*#/);

                if($_ =~ /^\s*username\s*=\s*(\S*)\s*/ && defined $1 && $1 ne '')
                {  $guid = $1;  }
            }
            close CRED;
        }
    }

    $url  = '' unless defined $url;
    $cert = '' unless defined $cert;
    $guid = '' unless defined $guid;

    return { "regserverurl" => $url,
             "regserverca"  => $cert,
             "guid"         => $guid };
}


BEGIN { $TYPEINFO{setregistrationconfig} = ["function", "integer", [ "map", "string", "string"] ]; }
sub setregistrationconfig
{
    my $self = shift;
    my $config = shift;

    my $SRconf     = '/etc/suseRegister.conf';
    my $SRcertpath = '/etc/ssl/certs/';
    my $SRcert     = "$SRcertpath/registration-server.pem";
    my $SRcertnew  = "$SRcertpath/registration-server.pem_new";

    my $url  = ${$config}{'regserverurl'} || undef;
    my $cert = ${$config}{'regserverca'}  || undef;
    my $newconfig = '';
    my $success = 0;

    # write the new registration server url to the suseRegister.conf file
    if ($url && $url =~ /^https:\/\//)
    {
        if ( -e $SRconf )
        {
            if (open(CNFR, "< $SRconf") )
            {
                while(<CNFR>)
                {
                    $_ =~ s/^url\s*=\s*(\S*)\s*/url = $url\n/;
                    $newconfig .= $_;
                }
                close CNFR;

                if ( open(CNFW, "> $SRconf") )
                {
                     print CNFW $newconfig;
                     close CNFW;
                     $success += 1;
                }
            }
        }
    }

    # write the new certificate and rehash the directory
    if ($cert)
    {
        if ( open(CERT, "> $SRcertnew") )
        {
            print CERT $cert;
            close CERT;
            # writing the file succeeded
            $success += 2;

            my @verifyargs = ('openssl', 'x509', '-in', "$SRcertnew", '-text');
            if ( system( @verifyargs ) == 0 )
            {
                my @moveargs = ('mv', "$SRcertnew", "$SRcert" );
                if ( system( @moveargs ) == 0 )
                {
                    # certificate validation succeeded and it was moved to the real file name
                    $success += 4;

                    # rehash the certificate pool
                    my @rehashargs = ('c_rehash', '/etc/ssl/certs/');
                    if ( system( @rehashargs ) == 0 )
                    {
                        # c_rehashing of certificate pool succeeded
                        $success += 8;
                    }
                }
            }
            else
            {
                # delete the *_new file
                unlink( $SRcertnew );
                # correct the success status
                $success -= 2;
            }
        }
    }

    return $success;
}


1;

#############################################################################
#############################################################################
#
# internal functions that should not be used directly by YaST (to prevent zypp deadlocks)
# they are here for documentation purposes or future use
#

# BEGIN { $TYPEINFO{get_ctx} = ["function", [ "map", "string", "any"]]; }
# sub get_ctx
# {
#    my $self = shift;

#    return $global_ctx;
# }

# BEGIN { $TYPEINFO{manageUpdateSources} = ["function", "void", [ "map", "string", "any"] ]; }
# sub manageUpdateSources
# {
#     my $self = shift;

#     return SUSE::SuseRegister::manageUpdateSources($global_ctx);
# }


# BEGIN { $TYPEINFO{addService} = ["function", ["list", "any"], [ "map", "string", "any"], [ "map", "string", "any"]]; }
# sub addService
# {
#     my $self = shift;
#     $global_ctx     = shift;
#     my $service = shift || undef;

#     return SUSE::SuseRegister::addService($global_ctx, $service);
# }


# BEGIN { $TYPEINFO{enableCatalog} = ["function", ["list", "any"], [ "map", "string", "any"], "string", [ "map", "string", "string"]]; }
# sub enableCatalog
# {
#     my $self = shift;
#     $global_ctx     = shift;
#     my $name    = shift || undef;
#     my $catalog = shift || undef;

#     return SUSE::SuseRegister::enableCatalog($global_ctx, $name, $catalog);
# }

# BEGIN { $TYPEINFO{deleteService} = ["function", ["list", "any"], [ "map", "string", "any"], [ "map", "string", "any"]]; }
# sub deleteService
# {
#     my $self = shift;
#     $global_ctx = shift;
#     my $service = shift || undef;

#     return SUSE::SuseRegister::deleteService($global_ctx, $service);
# }

# BEGIN { $TYPEINFO{disableCatalog} = ["function", ["list", "any"], [ "map", "string", "any"], "string", [ "map", "string", "string"]]; }
# sub disableCatalog
# {
#     my $self = shift;
#     $global_ctx     = shift;
#     my $name    = shift || undef;
#     my $catalog = shift || undef;

#     return SUSE::SuseRegister::disableCatalog($global_ctx, $name, $catalog);
# }

