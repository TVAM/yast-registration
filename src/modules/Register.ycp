/**
 * File:	modules/Register.ycp
 * Package:	Installation
 * Summary:	Registration related stuff
 * Authors:	J. Daniel Schmidt <jdsn@suse.de>
 *
 * $Id: Register.ycp 1 2005-03-13 08:45:05Z jdsn $
 */

{

module "Register";
textdomain "registration";

import "FileUtils";
import "Mode";
import "String";
import "Misc";
import "Stage";
import "Label";
import "Popup";
import "URL";
import "Linuxrc";
import "YSR";
import "ProductFeatures";
import "SourceManager";


// --------------------------------------------------------------
// START: Locally defined data
// --------------------------------------------------------------

string services_file = sformat ("%1/update_services", SCR::Read (.target.tmpdir));
boolean isInitializedSR = false;
map<string, any> contextDataSR = nil;
map<string, map<string, string> > argsDataSR = nil;
integer initialSRstatus = nil;
// ------------------------------------------------------------------
// END:   Locally defined data
// ------------------------------------------------------------------

// --------------------------------------------------------------
// START: Globally defined data, access via Register::<variable>
// --------------------------------------------------------------

global boolean autoYaSTModified = false;
global boolean do_registration = false;
global boolean iamroot = false;

global boolean submit_optional = false;
global boolean submit_hwdata   = false;
global boolean force_registration = false;
global boolean display_forcereg = false;
global boolean register_regularly = false;  // (FATE #301822)
global boolean disable_w3m = false;
global boolean use_proxy   = false;
global string  http_proxy  = "";
global string  https_proxy = "";
global string  smt_server  = "";            // (FATE #302966)
global string  smt_server_cert = "";        // (FATE #302966)
global boolean force_new_reg_url = false;

global map<string, string> registration_data = $[];

// ------------------------------------------------------------------
// END: Globally defined data, access via Register::<variable>
// ------------------------------------------------------------------


// ------------------------------------------------------------------
// START: Locally defined functions
// ------------------------------------------------------------------


/*
 * amIroot()
 *
 * checks if running as root
 * returns true if running as root - else returns false
 *
 */
boolean amIroot()
{
    // check if we are root
    map<string, any> userid = (map<string, any>) SCR::Execute(.target.bash_output, "id -u");
    y2milestone("running with user id %1", userid);
    return  String::FirstChunk(userid["stdout"]:"1", "\n") == "0" ? true:false;
}



/*
 * mountFloppy()
 *
 * mount a floppy disk
 * @return map with status information
 *
 */
map mountFloppy()
{
    // floppy mount support (FATE #303335)
    list drives = (list) SCR::Read(.probe.floppy);

    if ( size(drives) == 0 )
    {
        return $[ "mounted" : false ];
    }

    string fddevice = drives[0, "dev_name"]:"/dev/fd0";
    string tmpdir = (string) SCR::Read(.target.tmpdir);
    if (tmpdir == nil) tmpdir = "/tmp";
    string mpoint = tmpdir + "/fd";

    // create mount point directory
    SCR::Execute(.target.mkdir, mpoint);

    y2milestone("Trying to mount %1 as floppy drive to load the SMT certificate file from.", fddevice);

    boolean result = (boolean) SCR::Execute(.target.mount, [fddevice, mpoint], "-o ro" );

    return $[ "mounted" : result, "mpoint" : mpoint, "device" : fddevice ];
}



/*
 * umountFloppy()
 *
 * umount a floppy disk
 * @return void
 *
 */
void umountFloppy(string mpoint)
{
    if (mpoint == nil  ||  mpoint == "") return;
    SCR::Execute(.target.umount, mpoint);
}


/*
 * certificateError()
 *
 * report error messages if SMT certificate file is not found
 * @return symbol yes, no or retry
 *
 */
symbol certificateError(string heading, symbol type)
{
    if (heading == nil || heading == "") heading = _("Unknown error");

    string errorrMessage = "";
    string question = _("Do you want to skip Registration?");
    string otherwise = sformat( _("If you select %1 the Registration will most likely fail.
Otherwise you may copy the certificate file to the system manually
and then specify its path by choosing %2."), deletechars(Label::ContinueButton(), "&"), deletechars(Label::FileName(), "&") );
    string errorMessage = "";

    if (type == `floppy)
    {
        errorMessage = _("Could not load the SMT certificate file from floppy disk.");
    }
    else if (type == `url)
    {
        errorMessage = _("Could not download the SMT certificate file from specified URL.");
    }
    else if (type == `file)
    {
        errorMessage = _("Could not find the SMT certificate file in specified path.");
    }
    else
    {
        errorMessage = _("Unknown error occurred while retrieving SMT certificate file");
    }

    errorMessage = errorMessage  + "\n\n" + question + "\n\n" + otherwise;
    return Popup::AnyQuestion3(heading, errorMessage, _("Skip"), Label::ContinueButton(), Label::FileName(), `focus_yes );
}





/*
 * suseRegisterURL()
 *
 * get or set the suseRegisterURL
 * @return current url
 */
string suseRegisterURL(string url)
{
    // nil, empty string, unparsable urls and non-https urls as parameter means 'get url' else 'set url'

    string cururl = nil;
    map urlmap = $[];
    string suseRegisterConf = "/etc/suseRegister.conf";

    SCR::RegisterAgent (.temporary_suseregister_agent, `ag_ini(
        `IniAgent( suseRegisterConf,
        $[
            "options" : [ "line_can_continue", "global_values", "join_multiline", "comments_last", "flat" ],
            "comments": [ "^[ \t]*#.*$", "^[ \t]*$" ],
            "params" :  [ $[ "match" :     [ "([a-zA-Z0-9_-]+)[ \t]*=[ \t]*([^ \t]*)", "%s = %s" ] ] ]
        ]
    )));

    // in case the smt server was already changed do not change it again (to support mobile PCs in different environments)
    string mod = (string) SCR::Read(.temporary_suseregister_agent.smturlmodified);
    if (force_new_reg_url) mod = "false";

    if ( mod == "true" )
    {
        url = nil;
        y2milestone("SMT server has already been modified. I will not change it again.");
    }

    cururl = (string) SCR::Read(.temporary_suseregister_agent.url);
    urlmap = URL::Parse(url);

    if ( url != nil  &&  url != ""  &&  urlmap != $[]  &&  urlmap["scheme"]:"" == "https" )
    {
        SCR::Write(.temporary_suseregister_agent.url, url);
        cururl = (string) SCR::Read(.temporary_suseregister_agent.url);
        if (url == cururl) SCR::Write(.temporary_suseregister_agent.smturlmodified, "true");
    }

    SCR::UnregisterAgent (.temporary_suseregister_agent);
    return cururl;
}



/*
 * setupRegistrationServer()
 *
 * write SMT server settings to  (FATE #302966)
 * @return symbol that says if we can perform the registration
 *
 */
global symbol setupRegistrationServer(symbol mode)
{
    // in case smt_server is undefined nothing needs to be done
    if (smt_server == nil  ||  smt_server == "") return `ok;

    boolean ay = false;    // are we running in autoYaST mode?
    boolean trust = false;
    if (mode == `autoyast)
    {
        trust = true;
        ay = true;
    }

    string smtpemPath = "/etc/ssl/certs";
    string smtpemFile = smtpemPath + "/registration-server.pem";

    // check if smt_server is a valid url
    map smt_server_parsed = URL::Parse(smt_server);
    if (smt_server_parsed == $[]  ||  smt_server_parsed["host"]:"" == ""  ||  smt_server_parsed["scheme"]:"" != "https" )
    {
        y2milestone("The string '%1' could not be parsed and validated as URL to be used as SMT server.", smt_server);
        if (ay) return `conferror;

        string no_smt1 = _("The registration server URL could not be validated as URL.");
        string no_smt2 = _("Registration can not be performed.");
        string no_smt3 = _("Please change the URL and retry.");
        string no_smt_current = sformat( _("The current registration server URL is\n%1"), smt_server);

        string no_smt_server = sformat("%1\n%2\n%3\n\n%4", no_smt1, no_smt2, no_smt3, no_smt_current);

        Popup::Error(no_smt_server);
        return `conferror;
    }


    // write SMT server URL to /etc/suseRegister.conf
    if (smt_server == suseRegisterURL(smt_server) )
    { y2milestone("Setup custom SMT server as registration server successful: %1", smt_server); }
    else
    { y2error("Failed to setup custom SMT server as registration server: %1", smt_server);  }



    // ----------===============================================-------------- //

    symbol certmode = nil;

    // never ever load a certificate file for a *.novell.com smt server
    if      ( regexpmatch(smt_server_parsed["host"]:"", ".+\.novell\.com$"))
    {
        y2milestone("Registration detected a *.novell.com domain. For security reasons, there will be no certificate handling in this case.");
        y2milestone("In order to register at a *.novell.com domain, please make sure your registration server uses a trusted certificate and set regcert=done.");
        // allow override with  regcert="done" (bnc#413231)
        if   (smt_server_cert == "done")                            { certmode = `done;   }
        else                                                        { certmode = `none;   }
    }
    else if (smt_server_cert == nil  || smt_server_cert == "")      { certmode = `url;    }
    else if ( regexpmatch(smt_server_cert, "^(https?|ftp)://.+") )  { certmode = `url;    }
    else if ( regexpmatch(smt_server_cert, "^floppy/.+") )          { certmode = `floppy; }
    else if ( regexpmatch(smt_server_cert, "^/.+") )                { certmode = `path;   }
    else if ( smt_server_cert == "ask"  )                           { certmode = `ask;    }
    else if ( smt_server_cert == "done" )                           { certmode = `done;   }
    else                                                            { certmode = `none;   }


    if (! contains([`none, `done, `url, `floppy, `ask, `path], certmode) )
    {
        y2error("No SMT certificate file retrieval-mode found to handle current configuration. This should not happen!");
        return `conferror;
    }

    string certTmpFile = sformat("%1/__tmpSMTcert.crt", SCR::Read(.target.tmpdir));

    // check for existing certificate (bnc#376000)
    integer certExists = nil;
    certExists = (integer) SCR::Execute(.target.bash, sformat("[ -f  %1 ]", smtpemFile));
    if (certmode != `url  &&  certExists == 0)
    {
        // do nothing to refetch the certificate if manual interaction is necessary
        y2milestone("Existing SMT certificate found and keeping it. To renew the SMT certificate please assign a URL as value to the key 'regcert' in /var/lib/YaST2/install.inf");
        return `ok;
    }

    if ( certmode == `url )
    {
        map certParse = URL::Parse(smt_server_cert);

        // if no smt_server_cert is passed then we fall back to predefined smt_server_cert
        if (smt_server_cert == nil  ||  smt_server_cert == ""  ||  certParse == $[])
        {
            map certUrl = smt_server_parsed;
            certUrl["scheme"] = "http";
            certUrl["port"] = "80";
            certUrl["path"] = "/smt.crt";
            smt_server_cert = URL::Build(certUrl);
            certParse=certUrl;

        }
        y2milestone("Using %1 as URL to download the SMT certificate file.", smt_server_cert);

        // download cert
        string curlcmd = sformat("curl -f --connect-timeout 60  --max-time 120  '%1'   -o  %2", smt_server_cert, certTmpFile);
        if ( SCR::Execute(.target.bash, curlcmd) != 0)
        {
            if (certExists == 0)
            {
                // do nothing to refetch the certificate if manual interaction is necessary
                y2milestone("Could not download the current SMT certificate but existing certificate found and keeping it. To renew the SMT certificate please make sure it is available on the registration server.");
                return `ok;
            }

            y2error("Could not download the SMT certificate file from specified URL %1", smt_server_cert);
            if (ay) return `conferror;

            // translators: this is a heading for an error message - so no punctuation
            string urlError = _("Downloading SMT certificate file failed");
            symbol errret = certificateError( urlError, `url);

            certTmpFile = nil;
        }
    }

    if (certmode == `floppy)
    {
        // mount and copy
        map mf = mountFloppy();
        if (!mf["mounted"]:false)
        {
           umountFloppy(mf["mpoint"]:"/dev/fd0");
           y2error("Could not mount floppy disk to copy the SMT certificte file from. The device that was used was %1", mf["device"]:"");
           if (ay)
           {
               y2error("No SMT certificate file available. As we are in autoYaST mode Registration will be skipped. Please run it manually.");
               return `silentskip;
           }
           else
           {
               // translators: this is a heading for an error message - so no punctuation
               string fdMountError = _("Could not mount floppy disk");
               symbol errret = certificateError( fdMountError, `floppy);

               if ( errret == `yes )
               {
                   y2warning("No SMT certificate could be retrieved (floppy mount error). User selected to skip Registration.");
                   return `silentskip;
               }
               else if ( errret == `no )
               {
                   y2warning("No SMT certificate could be retrieved (floppy mount error). User selected to NOT skip Registration. Most likely Registration will fail now.");
                   return `ok;
               }
               else  { certmode = `ask; }
           }
        }
        else
        {
            string fdpath = regexpsub( smt_server_cert , "^floppy/(.+)$","\\1");
            string cp2tmp = sformat("/bin/cp -a  %1  %2 ", mf["mpoint"]:"/media/floppy" + "/" + fdpath, certTmpFile  );
            if ( SCR::Execute(.target.bash, cp2tmp) != 0)
            {
                y2error("Could not copy the specified SMT certificate file from floppy disk.");
                if (ay) return `silentskip;

                // translators: this is a heading for an error message - so no punctuation
                string fdCopyError = _("Could not read file floppy disk");
                symbol errret = certificateError( fdCopyError, `floppy);

                if ( errret == `yes )
                {
                    y2warning("No SMT certificate could be retrieved (could not copy from floppy). User selected to skip Registration.");
                    return `silentskip;
                }
                else if ( errret == `no )
                {
                    y2warning("No SMT certificate could be retrieved (could not copy from floppy). User selected to NOT skip Registration. Most likely Registration will fail now.");
                    return `ok;
                }
                else  { certmode = `ask; }

            }

            umountFloppy(mf["mpoint"]:"/dev/fd0");
        }

    }

    if (certmode == `path)
    {
        // try to copy cert if valid path,  else ask   // copy

        string cp2tmp = sformat(" [ -f  %1 ]  &&  /bin/cp -a  %1  %2 ", smt_server_cert, certTmpFile );
        if ( SCR::Execute(.target.bash, cp2tmp )  !=  0 )
        {
            y2error("Could not copy local SMT certificate file");
            if (ay) return `silentskip;

            // translators: this is a heading for an error message - so no punctuation
            string fileCopyError = _("Could find SMT certificate file in local path");
            symbol errret = certificateError( fileCopyError, `file);
            if ( errret == `yes )
            {
                y2warning("No SMT certificate could be retrieved (could not copy local file). User selected to skip Registration.");
                return `silentskip;
            }
            else if ( errret == `no )
            {
                y2warning("No SMT certificate could be retrieved (could not copy local file). User selected to NOT skip Registration. Most likely Registration will fail now.");
                return `ok;
            }
            else  { certmode = `ask; }
        }
    }

    if (certmode == `ask)
    {
        if (ay)
        {
            y2error("SMT certificate was configured to be asked for. AutoYaST does not support interactive dialogs. Registration will be skipped.");
            return `silentskip;
        }

        string basepath = "/tmp";
        string certFile = "";
        string selectCertLabel = _("Select SMT certificate file");
        boolean exitloop = false;

        do
        {
            do
            {
                certFile = UI::AskForExistingFile(basepath, "*.crt", selectCertLabel);
            } while (certFile == "");

            if (certFile == nil)
            {
                string skipReg = _("Do you really want to cancel and thereby skip the Registration?");
                if (Popup::YesNo(skipReg))
                {
                    y2milestone("User selected to cancel manual certificate dialog and thereby skip registration");
                    return `conferror;
                }
                else
                {
                    continue;
                }
            }

            string cp2tmp = sformat("/bin/cp -a  %1  %2 ", certFile , certTmpFile  );
            if (SCR::Execute(.target.bash, cp2tmp) == 0)
            {
                y2milestone("Found user specified SMT certificate file");
                exitloop = true;
            }
            else
            {
                y2milestone("Could not copy local file as SMT certificate");
                string fileErrorHeader = _("Could not copy certificate file");
                string fileErrorMsg    = _("Do you want to retry?");
                if (!Popup::YesNoHeadline(fileErrorHeader, fileErrorMsg))
                {
                    y2milestone("User selected to skip the setup of a SMT certificate");
                    return `conferror;
                }
            }

        } while ( !exitloop );


    }

    if (certmode == `done)
    {
        y2milestone("User configured to do nothing to retrieve a SMT certificate file.");
        y2milestone("I hope you know what you do. Registration will be run but may fail due to missing certificate.");
        return `ok;
    }

    if (certmode == `none)
    {
        y2warning("The string that was passed to get the SMT certificate file does not match any handler.");
        y2warning("The string was: %1", smt_server_cert);
        y2warning("No certificate could be retrieved. Registration process will not be run!");
        return `conferror;
    }



    // in autoYaST mode we automatically trust
    if ( !ay )  // (bnc#377929)
    {
        // ask user if he trusts the certificate

        // compare with existing certificate (bnc#376000)
        if (certExists == 0)
        {
            // we can only test if the files match - no parsing possible
            if ( ((integer)SCR::Execute(.target.bash, sformat("diff  %1  %2", certTmpFile, smtpemFile)) == 0 ))
            {
                // return `ok if fingerprints match - no need to ask again
                y2milestone("Current SMT certificate is up to date and will be kept.");
                return `ok;
            }
        }

        string trustQuestion = _("Do you want to trust this certificate?");
        string trustMessage  = _("This certificate will be used to connect to the SMT server.\nYou have to trust this certificate in order to continue with the Registration.");

        string certInfo = "";
        certInfo = (string) SCR::Read(.target.string, certTmpFile );

        UI::OpenDialog( `MinSize(70, 20, `VBox(
            `Left( `Label(`opt(`boldFont), trustQuestion)),
            `Left( `Label(trustMessage)),
            `RichText(sformat("%1",certInfo)),
            `HBox(`PushButton(`id(`trust), _("Trust")), `HSpacing(1.5), `PushButton(`id(`notrust), _("Reject")) )
        )));
        any uret = UI::UserInput();
        UI::CloseDialog();
        if ((symbol)uret == `trust) { trust = true; }
    }

    // (bnc#377929)
    if ( trust )
    {
        string installCert    = sformat("cp -a  %1  %2  &&  c_rehash %3", certTmpFile, smtpemFile, smtpemPath);
        string installCertZMD = sformat("[ -d /etc/zmd/trusted-certs ] &&  cp -a  %1  /etc/zmd/trusted-certs/registration-server.cer", certTmpFile);

        integer instret    = (integer) SCR::Execute(.target.bash, installCert);
        integer instretZMD = (integer) SCR::Execute(.target.bash, installCertZMD);

        if ( instret == 0 && instretZMD == 0)
        {
            y2milestone("Successfully installed SMT certificate. Registration will now proceed.");
            return `ok;
        }
        else
        {
            if (instret == 0 )
                y2error("Failed to install SMT certificate to common cert storage. Registration would fail and thus will be skipped.");
            if (instretZMD == 0)
                y2error("Failed to install SMT certificate for ZMD. Registration would fail and thus will be skipped.");

            if (!ay) Popup::Message(_("Installation of the SMT certificates failed.\nPlease see the logs for further information."));
            return `silentskip;
        }
    }
    else
    {
        y2milestone("User decided not to trust the SMT registration server certificate. Registration will be skipped.");
        return `notrust;
    }


    // a return to be safe :)
    return `conferror;

    // return value `ok           we can perform the registration
    //              `conferror    configuration error - we have to skip registration
    //              `notrust      user does not trust certificate - we have to skip registration
    //              `silentskip   autoyast mode skip registration on error
    //              `nil          unkown error - report generic error message
}



/*
 * configureRegistrationServer()
 *
 * read SMT server settings from install.inf and set them up (FATE #302966)
 *
 */
global symbol configureRegistrationServer()
{
    // boot parameters have a generic naming (regurl) - internally keeping smt for variable names
    smt_server = Linuxrc::InstallInf("regurl");
    smt_server_cert = Linuxrc::InstallInf("regcert");

    y2milestone("SMT config - regurl:  %1", smt_server);
    y2milestone("SMT config - regcert: %1", smt_server_cert);

/*  regurl=https:/smt.mybigcompany.com/center/regsvc/
    regcert=ask      open FileDialog
    regcert=done     Cert already insalled - do nothing
    regcert=http:/certpool.mybigcompany.com/smt/smt.crt     download from there
    regcert=floppy/path/to/file.crt
    regcert=/path/to/local/file.crt   copy from there

    the old parameters 'smturl' and 'smtcert' are supported as well
      but their values will be written to 'regurl' and 'regcert'
*/

    // setup the smt_server settings
    return setupRegistrationServer(nil);
}



/*
 * read_config()
 *
 * reads the configuration of the registration module from sysconfig and/or user's home
 *
 */
void read_config()
{
    // first read from control file
    submit_optional = ProductFeatures::GetBooleanFeature("globals", "enable_register_optional");
    submit_hwdata   = ProductFeatures::GetBooleanFeature("globals", "enable_register_hwdata");
    // this boolean comes only from the control file - nowhere to be saved
    display_forcereg = ProductFeatures::GetBooleanFeature("globals", "display_register_forcereg");
    disable_w3m = ProductFeatures::GetBooleanFeature("globals", "disable_register_w3m");

    register_regularly = ((integer) SCR::Execute(.target.bash, "[ -f /var/lib/suseRegister/neverRegisterOnBoot ]") ) == 0 ? false:true;
    // register_regularly = ProductFeatures::GetBooleanFeature("globals", "register_monthly");  // read default value - deactivated
    register_regularly = register_regularly  != nil ? register_regularly:false;

    // read proxy settings
    use_proxy   = (string) SCR::Read(.sysconfig.proxy.PROXY_ENABLED) == "yes" ? true:false;
    http_proxy  = (string) SCR::Read(.sysconfig.proxy.HTTP_PROXY);
    https_proxy = (string) SCR::Read(.sysconfig.proxy.HTTPS_PROXY);

    // proxy error handling now moved to the correct place (#208651)
    if ( ! use_proxy || http_proxy  == nil) http_proxy  = "";
    if ( ! use_proxy || https_proxy == nil) https_proxy = "";


    // then read from sysconfig - but not during installation
    if (Mode::normal())
    {   // (bnc#390367)
        string sysc_submit_optional = (string) SCR::Read( .sysconfig.suse_register.SUBMIT_OPTIONAL );
        string sysc_submit_hwdata   = (string) SCR::Read( .sysconfig.suse_register.SUBMIT_HWDATA );
        if (sysc_submit_optional != "")
        {
            submit_optional = sysc_submit_optional == "true" ? true:false;
        }
        if (sysc_submit_hwdata != "")
        {
            submit_hwdata   = sysc_submit_hwdata == "true" ? true:false;
        }
    }
}



/*
 * write_config()
 *
 * writes the configuration to the system
 * either to sysconfig if runnig as root or to user's home if running as non-root
 *
 */
void write_config()
{
    SCR::Write(.sysconfig.suse_register.SUBMIT_OPTIONAL, sformat("%1", submit_optional ? true:false ));
    SCR::Write(.sysconfig.suse_register.SUBMIT_HWDATA,   sformat("%1", submit_hwdata   ? true:false ));

    SCR::Execute(.target.bash, sformat("%1 /var/lib/suseRegister/neverRegisterOnBoot", register_regularly ? "rm -f ":"touch " ));
    // touch a flag file for opensuseupdater
    SCR::Execute(.target.bash, sformat("touch /var/lib/YaST2/registrationDidRun"));
}

// ------------------------------------------------------------------
// END: Locally defined functions
// ------------------------------------------------------------------


/*
 * initialize
 *
 * Initialize booleans: submit_optional, submit_hwdata and iamroot
 *
 */
integer suseRegisterOnce()
{
    // (#164794)
    // on behalf of hmuelle and shorn
    UI::OpenDialog(`VBox(
            // translators: busy popup while registering the system
            `Left( `Heading( _("Contacting server...")) ),
            // translators: Text for a busy-process-indicator while registering the system
            `BusyIndicator(`id(`busyContactingServer), _("This may take a while"), 300000 )
        ) );
    // Bug #171061 - Busy cursor during "Contacting server..."
    UI::BusyCursor();

    integer ret = YSR::register();

    // Bug #171061 - Changing back to normal cursor
    UI::NormalCursor();
    UI::CloseDialog();

    if(YSR::get_errorcode() != 0)
    {
        // error
        y2error("Register call failed (%1): %2", YSR::get_errorcode(), YSR::get_errormsg());
        return 111;
    }

    return ret;
}



/*
 * getSrcIdFromSrcMap
 *
 * get a SrcID from a sources list
 * takes a name of a source and the sources list<map> from Pkg::SourceEditGet()
 * @return: id of the found source, else nil
 */

integer getSrcIdFromSrcList(string name, list<map> allSrc)
{
    if ( name == nil  ||  name == "" )
    {
        y2error("Can not find a source with an empty or invalid name.");
        return nil;
    }
    else if ( allSrc == nil  ||  allSrc == [] )
    {
        y2error("Can not find a source in an empty sources list.");
        return nil;
    }

    integer foundSrc = nil;

    foreach(map srcMap, allSrc, {
        if ( is(srcMap["name"]:"", string) )
            if ( (string) srcMap["name"]:"" == name )
                if ( is(srcMap["SrcId"]:nil, integer) )
                    foundSrc = (integer) srcMap["SrcId"]:nil;
    });

    if ( foundSrc == nil )
        y2error("Could not find a source ID for the source with the name: %1", name);
    else
        y2milestone("Found a source id for a source: %1 (%2)", name, foundSrc);

    return foundSrc;
}

// ---------------------------------------------------------------------------------------
// START: Globally defined functions
// ---------------------------------------------------------------------------------------



/*
 * initialize
 *
 * Initialize booleans: submit_optional, submit_hwdata and iamroot
 *
 */
global void initialize()
{
    read_config();
    iamroot = amIroot();
}



/*
 * finish
 *
 * Finishing the modules stuff: calling write_config()
 *
 */
global void finish()
{
    iamroot = amIroot();
    write_config();
}



/*
 * add_update_sources
 *
 * read update sources from services file and add them to yast and zmd
 * @return a list of added URLs
 */
global list<string> add_update_sources ()
{
    if (!FileUtils::Exists (services_file))
	return [];

    // filters out empty items (#165860#c12)
    list<string> urls = String::NewlineItems (
	(string)SCR::Read(.target.string, services_file));

    return SourceManager::AddUpdateSources (urls);
}


/*
 * updateSoftwareRepositories
 *
 * takes a "taskList"-map from SuseRegister and updates the repositories
 * @return a list with a small summary (added/deleted/enabled/disabled repos)
 */
global list<string> updateSoftwareRepositories(map<string, any> taskList)
{
    // see if there are actions to perform
    if (taskList == $[])
    {
        return [];
    }

    list<string> summary = [];

    list<map> currentSources = Pkg::SourceEditGet();
    // log the sources for debugging purposes - FIXME - to be removed soon
    y2milestone("The current sources are: %1", currentSources);


    // outer foreach loop - loop over service names/aliases
    foreach( string pService, any pAny, taskList, {

        if ( ! is(pAny, map) )
        {
            y2error("A service returned by SuseRegister did not contain any details: %1", pService);
        }
        else if ( pService == nil || pService == "" )
        {
            y2error("A service returned by SuseRegister has no or an invalid name.");
        }
        else
        {
            if ( ! is( ((map) pAny)["TYPE"]:"", string) )
            {
                y2error("A service returned by SuseRegister has an invalid type: %1 (%2)", pService, ((map) pAny)["TYPE"]:"");
            }
            if ( ((map) pAny)["TYPE"]:"" == "zypp" )
            {
                y2milestone("Handling a service of the type zypp");
                if ( ! is( ((map) pAny)["TASK"]:"", string) )
                {
                    y2error("A service returned by SuseRegister has an invalid task: %1 (%2)", pService, ((map) pAny)["TASK"]:"" );
                }
                else if ( ((map) pAny)["TASK"]:"" == "le"  ||  ((map) pAny)["TASK"]:"" == "ld" )
                {
                    y2milestone("According to SuseRegister a service does not need to be changed: %1", pService);
                }
                else if ( ((map) pAny)["TASK"]:"" == "a" )
                {
                    // SourceAdd
                    y2milestone("According to SuseRegister a service has to be added: %1", pService);

                    // create map for new source
                    map<string, any> newSrcMap = $[  "enabled"       : true,
                                                     "autorefresh"   : true,
                                                     "name"          : (string) ((map) pAny)["NAME"]:"",
                                                     "alias"         : (string) ((map) pAny)["ALIAS"]:"",
                                                     "base_urls"     : [ (string) ((map) pAny)["URL"]:"" ],
                                                     "priority"      : ((map) pAny)["PRIORITY"]:99,
                                                   // ??  "prod_dir"      : ((map) pAny)["PROD_DIR"]:"",
                                                     "type"          : (string) ((map) pAny)["TYPE"]:""
                                                 ];

                    integer newSrcID = Pkg::RepositoryAdd( newSrcMap );

                    if ( newSrcID == nil )
                    {
                        y2error("Adding a new service failed: %1", pService );
                    }
                    else
                    {
                        y2milestone("Successfully added a new service: %1 (%2)", pService, newSrcID);
                        summary = add(summary, sformat(_("Added Source: %1"), pService ));
                    }

                }
                else if ( ((map) pAny)["TASK"]:"" == "d" )
                {
                    // SourceDelete
                    y2milestone("According to SuseRegister a service has to be deleted: %1", pService);

                    integer srcID = getSrcIdFromSrcList(pService, currentSources);
                    if ( srcID == nil )
                    {
                        y2error("A service that should be deleted can not be found: %1", pService);
                    }
                    else
                    {
                        if ( Pkg::SourceDelete(srcID) )
                        {
                            y2milestone("Successfully deleted a service: %1 (%2)", pService, srcID);
                            summary = add(summary, sformat(_("Deleted Source: %1"), pService));
                        }
                        else
                        {
                            y2error("Could not delete a service: %1 (%2)", pService, srcID);
                        }
                    }
                }
                else
                {
                    y2error("A service returned by SuseRegister has an unsupported task: %1 (%2)", pService, ((map) pAny)["TASK"]:"" );
                }

            }
            else if ( ((map) pAny)["TYPE"]:"" == "nu" )
            {
                y2milestone("Handling a service of the type nu");

                if ( ! is( ((map) pAny)["TASK"]:"", string) )
                {
                    y2error("A service returned by SuseRegister has an invalid task: %1 (%2)", pService, ((map) pAny)["TASK"]:"" );
                }
                else if ( ((map) pAny)["TASK"]:"" == "ld" )
                {
                    y2milestone("According to SuseRegister a service should be left disabled: %1", pService);
                }
                else if ( ((map) pAny)["TASK"]:"" == "le" )
                {
                    y2milestone("According to SuseRegister a service should be left enabled: %1", pService);
                    y2milestone("Now checking the catalogs of the service: %1", pService );

// ------------------->>>>> FIXME check catalogs!!!!!!!!
    // --> just iterate over catalogs
    // TODO

                }
                else if ( ((map) pAny)["TASK"]:"" == "a" )
                {
                    // ServiceAdd
                    y2milestone("According to SuseRegister a service has to be added: %1", pService);

                    if ( Pkg::ServiceAdd( ((map) pAny)["ALIAS"]:"",  ((map) pAny)["URL"]:"" ) )
                    {
                        y2milestone("Successfully added a new service: %1", pService);
                        y2milestone("Now checking the catalogs of the service: %1", pService);
			summary = add(summary, sformat(_("Added Service: %1"), pService ));

// ------------------->>>>> FIXME check catalogs!!!!!!!!
    // need to save service to the system first -- is this be done with  Pkg::SourceSaveAll()  ??  service != source  ??

                        if ( Pkg::SourceSaveAll() )
                        {
                            y2milestone("Successfully saved all sources.");
                        }
                        else
                        {
                            y2error("Could not save all sources.");
                        }

    // then need to call  Pkg::ServiceRefresh()
/*
                        if ( Pkg::ServiceRefresh(pService) )
                        {
                            y2milestone("Successfully refreshed service: %1", pService);
                        }
                        else
                        {
                            y2error("Could not refresh service: %1", pService);
                        }
*/
    // then iterate over catalogs
    // TODO

                    }
                    else
                    {
                        y2error("Adding a new service failed: %1", pService);
                    }

                }
                else if ( ((map) pAny)["TASK"]:"" == "d" )
                {
                    // ServiceDelete
                    y2milestone("According to SuseRegister a service has to be deleted: %1", pService);

                    if ( Pkg::ServiceDelete(pService) )
                    {
                        y2milestone("Successfully deleted a service: %1", pService);
			summary = add(summary, sformat(_("Deleted Service: %1"), pService ));
                    }
                    else
                    {
                        y2error("Could not delete a service: %1", pService);
                    }
                }
                else
                {
                    y2error("A service returned by SuseRegister has an unsupported task: %1 (%2)", pService, ((map) pAny)["TASK"]:"" );
                }
            }
            else
            {
                y2error("A service returned by SuseRegister has an unsupported type: %1 (%2)", pService, ((map) pAny)["TYPE"]:"" );
            }

        }
    });


    return summary;
}


/*
 * suseRegister()
 * return the error code of SuseRegister (via YSR.pm) as integer
*/
global integer suseRegister(symbol parameter)
{
    // FIXME -- THERE __MUST__ BE A SOURCE REFREH BEFORE INITIALIZING SUSEREGISTER

    map<string, any> contextData = $[
                                        "debug"             :  0,
                                        "nooptional"        :  (submit_optional    ? 0:1),
                                        "nohwdata"          :  (submit_hwdata      ? 0:1),
                                        "forceregistration" :  (force_registration ? 1:0),
                                        "yastcall"          :  1,
                                        "logfile"           :  "/root/.suse_register.log"
                                    ];
    y2milestone("Basic initialization data for SuseRegister (custom registration data is suppressed for security reasons): %1", contextData);

    // add data to the context from autoyast profile or from manual input
    if ( registration_data != $[] )
    {
        // append sensitive data to the context map
        foreach (string key, string val, registration_data,  {
            key = String::CutRegexMatch(key, "[^A-Za-z0-9_-]+", true );
            contextData[key] =  sformat("%1", String::Quote(val));
        });
        // do not log sensitive data to the log (#195624)
        y2milestone ("Added sensitive registration data to suse_register call - this data is not logged");
    }


    if (! isInitializedSR  || contextData != contextDataSR )
    {
        // initialize SuseRegister
        contextDataSR = contextData;
        y2milestone("Initializing SuseRegister with this context data: %1", contextDataSR);
        YSR::init_ctx(contextDataSR);
        isInitializedSR = true;

        // setting up proxy for SuseRegister
        if (Register::use_proxy)
        {
            if (Register::http_proxy  != nil &&  Register::https_proxy != nil)
            {
                y2milestone("Setting up proxy for SuseRegister. http_proxy: %1  -- https_proxy: %2", Register::http_proxy, Register::https_proxy);
                YSR::set_proxy(Register::http_proxy, Register::https_proxy);
            }
            else
            {
                y2error("Proxy settings are broken and could not be applied to SuseRegister.");
            }
        }
    }


    // ----====  handle modes for suseRegister  ====----


    // special mode for list-params
    // only makes sure registration is initialized
    if (parameter == `listparams)
    {
        y2milestone("Making sure suseregister is initialized for listparams");
        return 0;
    }


    // do the initial registration call if not done yet
    if ( initialSRstatus == nil )
    {
        integer retval = suseRegisterOnce();
        initialSRstatus = retval;
        if ( retval == 111 )
        {
            y2error("Initial register call failed (%1): %2", YSR::get_errorcode(), YSR::get_errormsg());
            y2error("Registration is not complete!");
            return 111;
        }
    }


    // we are in needinfo mode
    if ( initialSRstatus == 1 )
    {
        // send all data that can be gathered automatically by calling suseRegisterOnce again
        integer retval = suseRegisterOnce();
        if (retval == 111)
        {
            y2error("Register call failed in first needinfo state (%1): %2", YSR::get_errorcode(), YSR::get_errormsg());
            return 111;
        }

        // we are done - update the initial status variable
        y2milestone("After fist needinfo suseRegister returned with status: %1", retval);
        initialSRstatus = retval;
    }

    // everything fine - nothing to be done
    if ( initialSRstatus == 0 )
    {
        y2milestone("SuseRegister returned with status: %1", initialSRstatus);
    }


    if ( parameter == `autoyast )
    {
        string foo="bar";
        // TODO
        // call the function to sync the sources from here or from the Write function
    }

    y2milestone("SuseRegister status: %1", initialSRstatus);
    return initialSRstatus;
}


/*
 * suseRegisterListParams()
 * returns the text to display as details in the registration module
*/
global string suseRegisterListParams()
{
    y2milestone("User requested the args map. Collecting registration data details.");

    // make sure the suseRegister is initialized and the args map contains information
    integer retval = suseRegister(`listparams);
    if (retval == 0)
    {
        y2milestone("Registration data details map: %1", argsDataSR);
        return YSR::listParams();
    }

    y2error("Error occurred when collecting registration data details. The exit code was: %1", retval);
    return _("Error: Could not retrieve data.");
}



// ------------------------------------------------------------------
// END: Globally defined functions
// ------------------------------------------------------------------



/*
 * Read()
 */
global void Read()
{
    initialize();
}


/*
 * Import()
 */
global boolean Import(map settings)
{
    iamroot = amIroot();

    submit_optional = false;
    submit_hwdata   = false;
    do_registration = false;
    registration_data = $[];

    submit_optional     = (boolean) settings["submit_optional"]:submit_optional;
    submit_hwdata       = (boolean) settings["submit_hwdata"]:submit_hwdata;
    do_registration     = (boolean) settings["do_registration"]:do_registration;
    register_regularly  = (boolean) settings["register_regularly"]:register_regularly;
    registration_data   = (map<string, string>) settings["registration_data"]:$[];
    smt_server          = (string) settings["reg_server"]:"";
    smt_server_cert     = (string) settings["reg_server_cert"]:"";

    return true;
}



/*
 * Write()
 */
global boolean Write()
{
    iamroot = amIroot();
    setupRegistrationServer(`autoyast);
    if (do_registration) suseRegister(`autoyast);
    finish();
    return true;
}



/**
 * AutoYaST interface function: Export()
 * @return map with the settings
 */
global map Export()
{
    return $[
               "submit_optional":submit_optional,
               "submit_hwdata":submit_hwdata,
               "do_registration":do_registration,
               "register_regularly":register_regularly,
               "reg_server":smt_server,
               "reg_server_cert":smt_server_cert,
               "registration_data":registration_data
    ];
}

} // -EOF-
