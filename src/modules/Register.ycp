/**
 * File:	modules/Register.ycp
 * Package:	Installation
 * Summary:	Registration related stuff
 * Authors:	J. Daniel Schmidt <jdsn@suse.de>
 *
 * $Id: Register.ycp 1 2005-03-13 08:45:05Z jdsn $
 */

{

module "Register";
textdomain "registration";

import "FileUtils";
import "Mode";
import "String";
import "Misc";
import "Stage";
import "Label";
import "Popup";
import "URL";
import "Linuxrc";
import "YSR";
import "ProductFeatures";
import "SourceManager";
import "Installation";
import "RegisterCert";
import "Arch";

// --------------------------------------------------------------
// START: Locally defined data
// --------------------------------------------------------------

string services_file = sformat ("%1/update_services", SCR::Read (.target.tmpdir));
boolean isInitializedSR = false;
boolean isInitializedTarget = false;
map<string, any> contextDataSR = nil;
map<string, map<string, string> > argsDataSR = nil;
integer initialSRstatus = nil;
boolean repoUpdateSuccessful = true;  // flag success of repo changes for saveLastZmdConfig (bnc#435696)

// ------------------------------------------------------------------
// END:   Locally defined data
// ------------------------------------------------------------------

// --------------------------------------------------------------
// START: Globally defined data, access via Register::<variable>
// --------------------------------------------------------------

global boolean autoYaSTModified = false;
global boolean do_registration = false;
global boolean iamroot = false;

global boolean submit_optional = false;
global boolean submit_hwdata   = false;
global boolean force_registration = false;
global boolean display_forcereg = true;
global boolean register_regularly = false;  // (FATE #301822)
global boolean disable_w3m = false;
global boolean use_proxy   = false;
global string  http_proxy  = "";
global string  https_proxy = "";
global string  smt_server  = "";            // (FATE #302966)
global string  smt_server_cert = "";        // (FATE #302966)
global boolean force_new_reg_url = false;

global map<string, string> registration_data = $[];

// ------------------------------------------------------------------
// END: Globally defined data, access via Register::<variable>
// ------------------------------------------------------------------


// ------------------------------------------------------------------
// START: Locally defined functions
// ------------------------------------------------------------------


/*
 * amIroot()
 *
 * checks if running as root
 * returns true if running as root - else returns false
 *
 */
boolean amIroot()
{
    // check if we are root
    map<string, any> userid = (map<string, any>) SCR::Execute(.target.bash_output, "id -u");
    y2milestone("running with user id %1", userid);
    return  String::FirstChunk(userid["stdout"]:"1", "\n") == "0" ? true:false;
}



/*
 * mountFloppy()
 *
 * mount a floppy disk
 * @return map with status information
 *
 */
map mountFloppy()
{
    // floppy mount support (FATE #303335)
    list drives = (list) SCR::Read(.probe.floppy);

    if ( size(drives) == 0 )
    {
        return $[ "mounted" : false ];
    }

    string fddevice = drives[0, "dev_name"]:"/dev/fd0";
    string tmpdir = (string) SCR::Read(.target.tmpdir);
    if (tmpdir == nil) tmpdir = "/tmp";
    string mpoint = tmpdir + "/fd";

    // create mount point directory
    SCR::Execute(.target.mkdir, mpoint);

    y2milestone("Trying to mount %1 as floppy drive to load the SMT certificate file from.", fddevice);

    boolean result = (boolean) SCR::Execute(.target.mount, [fddevice, mpoint], "-o ro" );

    return $[ "mounted" : result, "mpoint" : mpoint, "device" : fddevice ];
}



/*
 * umountFloppy()
 *
 * umount a floppy disk
 * @return void
 *
 */
void umountFloppy(string mpoint)
{
    if (mpoint == nil  ||  mpoint == "") return;
    SCR::Execute(.target.umount, mpoint);
}


/*
 * certificateError()
 *
 * report error messages if SMT certificate file is not found
 * @return symbol yes, no or retry
 *
 */
symbol certificateError(string heading, symbol type)
{
    if (heading == nil || heading == "") heading = _("Unknown error");

    string errorrMessage = "";
    string question = _("Do you want to skip Registration?");
    string otherwise = sformat( _("If you select %1 the Registration will most likely fail.
Otherwise you may copy the certificate file to the system manually
and then specify its path by choosing %2."), deletechars(Label::ContinueButton(), "&"), deletechars(Label::FileName(), "&") );
    string errorMessage = "";

    if (type == `floppy)
    {
        errorMessage = _("Could not load the SMT certificate file from floppy disk.");
    }
    else if (type == `url)
    {
        errorMessage = _("Could not download the SMT certificate file from specified URL.");
    }
    else if (type == `file)
    {
        errorMessage = _("Could not find the SMT certificate file in specified path.");
    }
    else
    {
        errorMessage = _("Unknown error occurred while retrieving SMT certificate file");
    }

    errorMessage = errorMessage  + "\n\n" + question + "\n\n" + otherwise;
    return Popup::AnyQuestion3(heading, errorMessage, _("Skip"), Label::ContinueButton(), Label::FileName(), `focus_yes );
}





/*
 * suseRegisterURL()
 *
 * get or set the suseRegisterURL
 * @return current url
 */
string suseRegisterURL(string url)
{
    // nil, empty string, unparsable urls and non-https urls as parameter means 'get url' else 'set url'

    string cururl = nil;
    map urlmap = $[];
    string suseRegisterConf = "/etc/suseRegister.conf";

    SCR::RegisterAgent (.temporary_suseregister_agent, `ag_ini(
        `IniAgent( suseRegisterConf,
        $[
            "options" : [ "line_can_continue", "global_values", "join_multiline", "comments_last", "flat" ],
            "comments": [ "^[ \t]*#.*$", "^[ \t]*$" ],
            "params" :  [ $[ "match" :     [ "([a-zA-Z0-9_-]+)[ \t]*=[ \t]*([^ \t]*)", "%s = %s" ] ] ]
        ]
    )));

    // in case the smt server was already changed do not change it again (to support mobile PCs in different environments)
    string mod = (string) SCR::Read(.temporary_suseregister_agent.smturlmodified);
    if (force_new_reg_url) mod = "false";

    if ( mod == "true" )
    {
        url = nil;
        y2milestone("SMT server has already been modified. I will not change it again.");
    }

    cururl = (string) SCR::Read(.temporary_suseregister_agent.url);
    urlmap = URL::Parse(url);

    if ( url != nil  &&  url != ""  &&  urlmap != $[]  &&  urlmap["scheme"]:"" == "https" )
    {
        SCR::Write(.temporary_suseregister_agent.url, url);
        cururl = (string) SCR::Read(.temporary_suseregister_agent.url);
        if (url == cururl) SCR::Write(.temporary_suseregister_agent.smturlmodified, "true");
    }

    SCR::UnregisterAgent (.temporary_suseregister_agent);
    return cururl;
}


/*
 * setupRegistrationServer()
 *
 * write SMT server settings to  (FATE #302966)
 * @return symbol that says if we can perform the registration
 *
 */
global symbol xenType()
{
    y2milestone("Checking if this machine is a XEN instance or host.");

    if ( Arch::is_xen() )
    {
        y2milestone("XEN enabled. Now detecting type.");

        if ( Arch::is_xen0() )
        {
            y2milestone("Detected XEN0.");
            return `xen0;
        }
        else if ( Arch::is_xenU() )
        {
            y2milestone("Detected XENU");
            return `xenU;
        }
    }
    else
    {
        y2milestone("XEN is disabled.");
        return `noXen;
    }

    y2error("An error occurred while detecting XEN. Assuming: XEN is disabled.");
    return `unknown;
}



/*
 * setupRegistrationServer()
 *
 * write SMT server settings to  (FATE #302966)
 * @return symbol that says if we can perform the registration
 *
 */
global symbol setupRegistrationServer(symbol mode)
{
    // invalidate a previous registration initialization as now settings may change (bnc#557194)
    isInitializedSR = false;
    // in case smt_server is undefined nothing needs to be done
    if (smt_server == nil  ||  smt_server == "") return `ok;

    boolean ay = false;    // are we running in autoYaST mode?
    boolean trust = false;
    if (mode == `autoyast)
    {
        trust = true;
        ay = true;
    }

    string smtpemPath = "/etc/ssl/certs";
    string smtpemFile = smtpemPath + "/registration-server.pem";

    // check if smt_server is a valid url
    map smt_server_parsed = URL::Parse(smt_server);
    if (smt_server_parsed == $[]  ||  smt_server_parsed["host"]:"" == ""  ||  smt_server_parsed["scheme"]:"" != "https" )
    {
        y2milestone("The string '%1' could not be parsed and validated as URL to be used as SMT server.", smt_server);
        if (ay) return `conferror;

        string no_smt1 = _("The registration server URL could not be validated as URL.");
        string no_smt2 = _("Registration can not be performed.");
        string no_smt3 = _("Please change the URL and retry.");
        string no_smt_current = sformat( _("The current registration server URL is\n%1"), smt_server);

        string no_smt_server = sformat("%1\n%2\n%3\n\n%4", no_smt1, no_smt2, no_smt3, no_smt_current);

        Popup::Error(no_smt_server);
        return `conferror;
    }


    // write SMT server URL to /etc/suseRegister.conf
    if (smt_server == suseRegisterURL(smt_server) )
    { y2milestone("Setup custom SMT server as registration server successful: %1", smt_server); }
    else
    { y2error("Failed to setup custom SMT server as registration server: %1", smt_server);  }



    // ----------===============================================-------------- //

    symbol certmode = nil;

    // never ever load a certificate file for a *.novell.com smt server
    if      ( regexpmatch(smt_server_parsed["host"]:"", ".+\.novell\.com$"))
    {
        y2milestone("Registration detected a *.novell.com domain. For security reasons, there will be no certificate handling in this case.");
        y2milestone("In order to register at a *.novell.com domain, please make sure your registration server uses a trusted certificate and set regcert=done.");
        // allow override with  regcert="done" (bnc#413231)
        if   (smt_server_cert == "done")                            { certmode = `done;   }
        else                                                        { certmode = `none;   }
    }
    else if (smt_server_cert == nil  || smt_server_cert == "")      { certmode = `url;    }
    else if ( regexpmatch(smt_server_cert, "^(https?|ftp)://.+") )  { certmode = `url;    }
    else if ( regexpmatch(smt_server_cert, "^floppy/.+") )          { certmode = `floppy; }
    else if ( regexpmatch(smt_server_cert, "^/.+") )                { certmode = `path;   }
    else if ( smt_server_cert == "ask"  )                           { certmode = `ask;    }
    else if ( smt_server_cert == "done" )                           { certmode = `done;   }
    else                                                            { certmode = `none;   }


    if (! contains([`none, `done, `url, `floppy, `ask, `path], certmode) )
    {
        y2error("No SMT certificate file retrieval-mode found to handle current configuration. This should not happen!");
        return `conferror;
    }

    string certTmpFile = sformat("%1/__tmpSMTcert.crt", SCR::Read(.target.tmpdir));

    // check for existing certificate (bnc#376000)
    boolean certExists = false;
    certExists = ( (integer) SCR::Execute(.target.bash, sformat("[ -f  %1 ]", smtpemFile))  ==  0 )  ?  true:false;
    if (certmode != `url  &&  certExists )
    {
        // do nothing to refetch the certificate if manual interaction is necessary
        y2milestone("Existing SMT certificate found and keeping it. To renew the SMT certificate please assign a URL as value to the key 'regcert' in /var/lib/YaST2/install.inf");
        return `ok;
    }

    if ( certmode == `url )
    {
        map certParse = URL::Parse(smt_server_cert);

        // if no smt_server_cert is passed then we fall back to predefined smt_server_cert
        if (smt_server_cert == nil  ||  smt_server_cert == ""  ||  certParse == $[])
        {
            map certUrl = smt_server_parsed;
            certUrl["scheme"] = "http";
            certUrl["port"] = "80";
            certUrl["path"] = "/smt.crt";
            smt_server_cert = URL::Build(certUrl);
            certParse=certUrl;

        }
        y2milestone("Using %1 as URL to download the SMT certificate file.", smt_server_cert);

        // download cert
        string curlcmd = sformat("curl -f --connect-timeout 60  --max-time 120  '%1'   -o  %2", smt_server_cert, certTmpFile);
        if ( SCR::Execute(.target.bash, curlcmd) != 0)
        {
            if ( certExists )
            {
                // do nothing to refetch the certificate if manual interaction is necessary
                y2milestone("Could not download the current SMT certificate but existing certificate found and keeping it. To renew the SMT certificate please make sure it is available on the registration server.");
                return `ok;
            }

            y2error("Could not download the SMT certificate file from specified URL %1", smt_server_cert);
            if (ay) return `conferror;

            // translators: this is a heading for an error message - so no punctuation
            string urlError = _("Downloading SMT certificate file failed");
            symbol errret = certificateError( urlError, `url);

            if ( errret == `yes )
            {
                y2warning("No SMT certificate could be retrieved (floppy mount error). User selected to skip Registration.");
                return `silentskip;
            }
            else if ( errret == `no )
            {
                y2warning("No SMT certificate could be retrieved (floppy mount error). User selected to NOT skip Registration. Most likely Registration will fail now.");
                return `ok;
            }
            else  { certmode = `ask; }

            certTmpFile = nil;
        }
    }

    if (certmode == `floppy)
    {
        // mount and copy
        map mf = mountFloppy();
        if (!mf["mounted"]:false)
        {
           umountFloppy(mf["mpoint"]:"/dev/fd0");
           y2error("Could not mount floppy disk to copy the SMT certificte file from. The device that was used was %1", mf["device"]:"");
           if (ay)
           {
               y2error("No SMT certificate file available. As we are in autoYaST mode Registration will be skipped. Please run it manually.");
               return `silentskip;
           }
           else
           {
               // translators: this is a heading for an error message - so no punctuation
               string fdMountError = _("Could not mount floppy disk");
               symbol errret = certificateError( fdMountError, `floppy);

               if ( errret == `yes )
               {
                   y2warning("No SMT certificate could be retrieved (floppy mount error). User selected to skip Registration.");
                   return `silentskip;
               }
               else if ( errret == `no )
               {
                   y2warning("No SMT certificate could be retrieved (floppy mount error). User selected to NOT skip Registration. Most likely Registration will fail now.");
                   return `ok;
               }
               else  { certmode = `ask; }
           }
        }
        else
        {
            string fdpath = regexpsub( smt_server_cert , "^floppy/(.+)$","\\1");
            string cp2tmp = sformat("/bin/cp -a  %1  %2 ", mf["mpoint"]:"/media/floppy" + "/" + fdpath, certTmpFile  );
            if ( SCR::Execute(.target.bash, cp2tmp) != 0)
            {
                y2error("Could not copy the specified SMT certificate file from floppy disk.");
                if (ay) return `silentskip;

                // translators: this is a heading for an error message - so no punctuation
                string fdCopyError = _("Could not read file floppy disk");
                symbol errret = certificateError( fdCopyError, `floppy);

                if ( errret == `yes )
                {
                    y2warning("No SMT certificate could be retrieved (could not copy from floppy). User selected to skip Registration.");
                    return `silentskip;
                }
                else if ( errret == `no )
                {
                    y2warning("No SMT certificate could be retrieved (could not copy from floppy). User selected to NOT skip Registration. Most likely Registration will fail now.");
                    return `ok;
                }
                else  { certmode = `ask; }

            }

            umountFloppy(mf["mpoint"]:"/dev/fd0");
        }

    }

    if (certmode == `path)
    {
        // try to copy cert if valid path,  else ask   // copy

        string cp2tmp = sformat(" [ -f  %1 ]  &&  /bin/cp -a  %1  %2 ", smt_server_cert, certTmpFile );
        if ( SCR::Execute(.target.bash, cp2tmp )  !=  0 )
        {
            y2error("Could not copy local SMT certificate file");
            if (ay) return `silentskip;

            // translators: this is a heading for an error message - so no punctuation
            string fileCopyError = _("Could find SMT certificate file in local path");
            symbol errret = certificateError( fileCopyError, `file);
            if ( errret == `yes )
            {
                y2warning("No SMT certificate could be retrieved (could not copy local file). User selected to skip Registration.");
                return `silentskip;
            }
            else if ( errret == `no )
            {
                y2warning("No SMT certificate could be retrieved (could not copy local file). User selected to NOT skip Registration. Most likely Registration will fail now.");
                return `ok;
            }
            else  { certmode = `ask; }
        }
    }

    if (certmode == `ask)
    {
        if (ay)
        {
            y2error("SMT certificate was configured to be asked for. AutoYaST does not support interactive dialogs. Registration will be skipped.");
            return `silentskip;
        }

        string basepath = "/tmp";
        string certFile = "";
        string selectCertLabel = _("Select SMT certificate file");
        boolean exitloop = false;

        do
        {
            do
            {
                certFile = UI::AskForExistingFile(basepath, "*.crt", selectCertLabel);
            } while (certFile == "");

            if (certFile == nil)
            {
                string skipReg = _("Do you really want to cancel and thereby skip the Registration?");
                if (Popup::YesNo(skipReg))
                {
                    y2milestone("User selected to cancel manual certificate dialog and thereby skip registration");
                    return `conferror;
                }
                else
                {
                    continue;
                }
            }

            string cp2tmp = sformat("/bin/cp -a  %1  %2 ", certFile , certTmpFile  );
            if (SCR::Execute(.target.bash, cp2tmp) == 0)
            {
                y2milestone("Found user specified SMT certificate file");
                exitloop = true;
            }
            else
            {
                y2milestone("Could not copy local file as SMT certificate");
                string fileErrorHeader = _("Could not copy certificate file");
                string fileErrorMsg    = _("Do you want to retry?");
                if (!Popup::YesNoHeadline(fileErrorHeader, fileErrorMsg))
                {
                    y2milestone("User selected to skip the setup of a SMT certificate");
                    return `conferror;
                }
            }

        } while ( !exitloop );


    }

    if (certmode == `done)
    {
        y2milestone("User configured to do nothing to retrieve a SMT certificate file.");
        y2milestone("I hope you know what you do. Registration will be run but may fail due to missing certificate.");
        return `ok;
    }

    if (certmode == `none)
    {
        y2warning("The string that was passed to get the SMT certificate file does not match any handler.");
        y2warning("The string was: %1", smt_server_cert);
        y2warning("No certificate could be retrieved. Registration process will not be run!");
        return `conferror;
    }


    // log certificate details
    if ( certTmpFile == nil  ||  certTmpFile == "" )
    {
        y2error("Copying the CA certificate file failed");
        return `conferror;
    }

    map cP = RegisterCert::parseCertificate(certTmpFile);
    y2milestone("SMT certificate file information: %1", cP);

    // now ask user if he trusts the certificate
    // in autoYaST mode we automatically trust
    if ( !ay )  // (bnc#377929)
    {
        // compare with existing certificate (bnc#376000)
        if ( certExists )
        {
            map orig_cP = RegisterCert::parseCertificate(smtpemFile);
            if (orig_cP["FINGERPRINT"]:"foo" == cP["FINGERPRINT"]:"bar" )
            {
                // return `ok if fingerprints match - no need to ask again
                y2milestone("Current SMT certificate is up to date and will be kept.");
                return `ok;
            }
        }

        string trustQuestion = _("Do you want to trust this certificate?");
        string trustMessage  = _("This certificate will be used to connect to the SMT server.\nYou have to trust this certificate in order to continue with the Registration.");

        string certInfo = "";

        list issueList = (list) cP["ISSUER"]:[];
        //translators: this is certificate context
        certInfo = certInfo + _("<p><b>Issued For:</b></p>");
        if (size (issueList) > 0)
        {
            certInfo = certInfo + "<pre>";
            foreach (map<string,string> keyval, (list<map<string,string> >) issueList, {
                foreach (string key, string val, (map<string, string>) keyval, {
                    certInfo = certInfo + sformat("\n%1:  %2", key, val);
                });
            });
            certInfo = certInfo + "</pre>";
        }

        //translators: this is certificate context
        certInfo = certInfo + _("<p><b>Subject:</b></p>");
        list subjectList=(list) cP["SUBJECT"]:[];
        if (size (subjectList) > 0)
        {
            certInfo = certInfo + "<pre>";
            foreach (map<string, string> keyval, (list<map<string,string> >) subjectList, {
                foreach (string key, string val, (map<string,string>)keyval, {
                    certInfo = certInfo + sformat("\n%1:  %2", key, val);
                });
            });
            certInfo = certInfo + "</pre>";
        }
        //translators: this is certificate context
        certInfo = certInfo + _("<p><b>Validity:</b></p>");
        certInfo = certInfo + "<pre>";
        //translators: this is certificate context
        certInfo = certInfo + "\n" + _("Valid from: ")  + " " + cP["STARTDATE"]:"";
        //translators: this is certificate context
        certInfo = certInfo + "\n" + _("Valid to: ")  + " " + cP["ENDDATE"]:"";
        //translators: this is certificate context
        certInfo = certInfo + "\n" + _("Fingerprint: ") + " " + cP["FINGERPRINT"]:"";
        certInfo = certInfo + "</pre>";

        // certInfo = (string) SCR::Read(.target.string, certTmpFile );  // show the certificate file content -- for debugging only

        UI::OpenDialog( `MinSize(70, 20, `VBox(
            `Left( `Label(`opt(`boldFont), trustQuestion)),
            `Left( `Label(trustMessage)),
            `RichText(sformat("%1",certInfo)),
            `HBox(`PushButton(`id(`trust), _("Trust")), `HSpacing(1.5), `PushButton(`id(`notrust), _("Reject")) )
        )));
        any uret = UI::UserInput();
        UI::CloseDialog();
        if ((symbol)uret == `trust) { trust = true; }
    }

    // (bnc#377929)
    if ( trust )
    {
        string installCert    = sformat("cp -a  %1  %2  &&  c_rehash %3", certTmpFile, smtpemFile, smtpemPath);
        // removed installing the certificate as well to zmd (bnc#435631)

        if ( (integer) SCR::Execute(.target.bash, installCert) == 0 )
        {
            y2milestone("Successfully installed SMT certificate. Registration will now proceed.");
            return `ok;
        }
        else
        {
            y2error("Failed to install SMT certificate to common cert storage. Registration would fail and thus will be skipped.");

            if (!ay) Popup::Message(_("Installation of the SMT certificates failed.\nPlease see the logs for further information."));
            return `silentskip;
        }
    }
    else
    {
        y2milestone("User decided not to trust the SMT registration server certificate. Registration will be skipped.");
        return `notrust;
    }


    // a return to be safe :)
    return `conferror;

    // return value `ok           we can perform the registration
    //              `conferror    configuration error - we have to skip registration
    //              `notrust      user does not trust certificate - we have to skip registration
    //              `silentskip   autoyast mode skip registration on error
    //              `nil          unkown error - report generic error message
}



/*
 * configureRegistrationServer()
 *
 * read SMT server settings from install.inf and set them up (FATE #302966)
 *
 */
global symbol configureRegistrationServer()
{
    // boot parameters have a generic naming (regurl) - internally keeping smt for variable names
    smt_server = Linuxrc::InstallInf("regurl");
    smt_server_cert = Linuxrc::InstallInf("regcert");

    y2milestone("SMT config - regurl:  %1", smt_server);
    y2milestone("SMT config - regcert: %1", smt_server_cert);

/*  regurl=https:/smt.mybigcompany.com/center/regsvc/
    regcert=ask      open FileDialog
    regcert=done     Cert already insalled - do nothing
    regcert=http:/certpool.mybigcompany.com/smt/smt.crt     download from there
    regcert=floppy/path/to/file.crt
    regcert=/path/to/local/file.crt   copy from there

    the old parameters 'smturl' and 'smtcert' are supported as well
      but their values will be written to 'regurl' and 'regcert'
*/

    // setup the smt_server settings
    return setupRegistrationServer(nil);
}



/*
 * read_config()
 *
 * reads the configuration of the registration module from sysconfig and/or user's home
 *
 */
void read_config()
{
    // first read from control file
    submit_optional = ProductFeatures::GetBooleanFeature("globals", "enable_register_optional");
    submit_hwdata   = ProductFeatures::GetBooleanFeature("globals", "enable_register_hwdata");
    // this boolean comes only from the control file - nowhere to be saved
    // do never hide the regcode checkbox, fix on behalf of (bnc#784588) as its fix will not hit already installed systems
    //display_forcereg = ProductFeatures::GetBooleanFeature("globals", "display_register_forcereg");
    display_forcereg = true;
    disable_w3m = ProductFeatures::GetBooleanFeature("globals", "disable_register_w3m");

    register_regularly = ((integer) SCR::Execute(.target.bash, "[ -f /var/lib/suseRegister/neverRegisterOnBoot ]") ) == 0 ? false:true;
    // register_regularly = ProductFeatures::GetBooleanFeature("globals", "register_monthly");  // read default value - deactivated
    register_regularly = register_regularly  != nil ? register_regularly:false;

    // read proxy settings
    use_proxy   = (string) SCR::Read(.sysconfig.proxy.PROXY_ENABLED) == "yes" ? true:false;
    http_proxy  = (string) SCR::Read(.sysconfig.proxy.HTTP_PROXY);
    https_proxy = (string) SCR::Read(.sysconfig.proxy.HTTPS_PROXY);

    // proxy error handling now moved to the correct place (#208651)
    if ( ! use_proxy || http_proxy  == nil) http_proxy  = "";
    if ( ! use_proxy || https_proxy == nil) https_proxy = "";


    // then read from sysconfig - but not during installation
    if (Mode::normal())
    {   // (bnc#390367)
        string sysc_submit_optional = (string) SCR::Read( .sysconfig.suse_register.SUBMIT_OPTIONAL );
        string sysc_submit_hwdata   = (string) SCR::Read( .sysconfig.suse_register.SUBMIT_HWDATA );
        if (sysc_submit_optional != "")
        {
            submit_optional = sysc_submit_optional == "true" ? true:false;
        }
        if (sysc_submit_hwdata != "")
        {
            submit_hwdata   = sysc_submit_hwdata == "true" ? true:false;
        }
    }
}



/*
 * write_config()
 *
 * writes the configuration to the system
 * either to sysconfig if runnig as root or to user's home if running as non-root
 *
 */
void write_config()
{
    SCR::Write(.sysconfig.suse_register.SUBMIT_OPTIONAL, sformat("%1", submit_optional == true ? true:false ));
    SCR::Write(.sysconfig.suse_register.SUBMIT_HWDATA,   sformat("%1", submit_hwdata   == true ? true:false ));

    if ( register_regularly == nil ) register_regularly = false;
    SCR::Execute(.target.bash, sformat("%1 /var/lib/suseRegister/neverRegisterOnBoot", register_regularly == true ? "rm -f ":"touch " ));
    // touch a flag file for opensuseupdater
    SCR::Execute(.target.bash, sformat("touch /var/lib/YaST2/registrationDidRun"));
}

// ------------------------------------------------------------------
// END: Locally defined functions
// ------------------------------------------------------------------


/*
 * initialize
 *
 * Initialize booleans: submit_optional, submit_hwdata and iamroot
 *
 */
integer suseRegisterOnce()
{
    // (#164794)
    // on behalf of hmuelle and shorn
    UI::OpenDialog(`VBox(
            // translators: busy popup while registering the system
            `Left( `Heading( _("Contacting server...")) ),
            // translators: Text for a busy-process-indicator while registering the system
            `BusyIndicator(`id(`busyContactingServer), _("This may take a while"), 300000 )
        ) );
    // Bug #171061 - Busy cursor during "Contacting server..."
    UI::BusyCursor();

    integer ret = YSR::register();

    // Bug #171061 - Changing back to normal cursor
    UI::NormalCursor();
    UI::CloseDialog();

    integer errorCode = YSR::get_errorcode();
    if( errorCode != 0 )
    {
        // error
        y2warning("Register call returned with an error message (error code: %1): %2", errorCode, YSR::get_errormsg());
        y2warning("This basically means registration is not finished yet.");
    }

    return ret;
}



/*
 * getSrcIdFromSrcMap
 *
 * get a SrcID from a sources list
 * takes a name of a source and the sources list<map> from Pkg::SourceEditGet()
 * @return: id of the found source, else nil
 */

integer getSrcIdFromSrcList(string name, list<map> allSrc)
{
    if ( name == nil  ||  name == "" )
    {
        y2error("Can not find a source with an empty or invalid name.");
        return nil;
    }
    else if ( allSrc == nil  ||  allSrc == [] )
    {
        y2error("Can not find a source in an empty sources list.");
        return nil;
    }

    integer foundSrc = nil;

    foreach(map srcMap, allSrc, {
        if ( is(srcMap["name"]:"", string) )
            if ( (string) srcMap["name"]:"" == name )
                if ( is(srcMap["SrcId"]:nil, integer) )
                    foundSrc = (integer) srcMap["SrcId"]:nil;
    });

    if ( foundSrc == nil )
        y2error("Could not find a source ID for the source with the name: %1", name);
    else
        y2milestone("Found a source id for a source: %1 (%2)", name, foundSrc);

    return foundSrc;
}

// ---------------------------------------------------------------------------------------
// START: Globally defined functions
// ---------------------------------------------------------------------------------------



/*
 * initialize
 *
 * Initialize booleans: submit_optional, submit_hwdata and iamroot
 *
 */
global void initialize()
{
    read_config();
    iamroot = amIroot();
}



/*
 * finish
 *
 * Finishing the modules stuff: calling write_config()
 *
 */
global void finish()
{
    iamroot = amIroot();
    write_config();
    // reset YSRs context
    YSR::del_ctx();
    isInitializedSR = false;
    if ( isInitializedTarget )
    {
        // do no longer call TargetFinish (bnc#468449)
        // Note: repeated calls to TargetInitialize with the same rootdir are ok, see libzypp/zypp/zypp_detail/ZYppImpl.cc:95
        y2debug("The Target currently is initialized - but due to bug bnc#468449 Pkg::TargetFinish will not be called.");

        // keep it initialized but enforce a re-initialization if a workflow returns back to registration (bnc#576532)
        isInitializedTarget = false;
    }
}


/*
 * callbackAuthenticationOnRefresh
 * dummy callbackfunction to disable the authentication errors
 */
global map<string, any> callbackAuthenticationOnRefresh()
{
    y2error("Refreshing a service or repository filed because of an authentication error.");
    y2error("This is a valid scenario though, and only means that registration needs to be run.");
    y2error("Registration will now continue without a warning to the user.");
    return (map<string, any>) $[ "continue" : false,
                                 "username" : "",
                                 "password" : ""      ];
}


/*
 * checkCatalogs
 *
 * takes a sub-"taskList"-map (catalogs-map) from SuseRegister and updates listed repositories
 * @return a list with a small summary (added/deleted/enabled/disabled repos)
 */
global list<string> checkCatalogs(map<string, any> taskList, string service)
{
    y2debug("Task list of check catalogs for the service (%1): %2", service, taskList);

    list<string> cSummary = [];
    list<string> catalogToEnable = [];
    list<string> catalogToDisable = [];

    foreach (string catalog, any pAny, taskList, {
        if ( ! is(pAny, map) )
        {
            y2error("A catalog returned by SuseRegister did not contain any details: %1", catalog);
            repoUpdateSuccessful = false;
        }
        else if ( catalog == nil  || catalog == "" )
        {
            y2error("A catalog returned by SuseRegister has no or an invalid name.");
            repoUpdateSuccessful = false;
        }
        else
        {
            map catDetail = (map) pAny;

            if ( catDetail["ALIAS"]:"" == nil  ||  catDetail["ALIAS"]:"" == "" )
            {
                y2error("A catalog returned by SuseRegister has no or an invalid alias name.");
                repoUpdateSuccessful = false;
            }
            else
            {
                if ( catDetail["TASK"]:"" == nil  ||  catDetail["TASK"]:"" == "" )
                {
                    y2error("A catalog returned by SuseRegister has an invalid task: %1", catalog);
                    repoUpdateSuccessful = false;
                }
                else if ( catDetail["TASK"]:"" == "le"  ||  catDetail["TASK"]:"" == "ld" )
                {
                    y2milestone("According to SuseRegister a catalog does not need to be changed: %1 (%2)", catalog, service);
                }
                else if ( catDetail["TASK"]:"" ==  "a" )
                {
                    y2milestone("According to SuseRegister a catalog has to be enabled: %1 (%2)", catalog, service);
                    catalogToEnable = add(catalogToEnable, catalog);
                    cSummary = add(cSummary, sformat(_("Enabled catalog: %1 (%2)"), catalog, service) );
                }
                else if ( catDetail["TASK"]:"" ==  "d" )
                {
                    y2milestone("According to SuseRegister a service has to be disabled: %1 (%2)", catalog, service);
                    catalogToDisable = add(catalogToDisable, catalog);
                    cSummary = add(cSummary, sformat(_("Disabled catalog: %1 (%2)"), catalog, service) );
                }
                else
                {
                    y2error("A catalog returned by SuseRegister has an unsupported task: %1 (%2)", catalog, service);
                    repoUpdateSuccessful = false;
                }
            }
        }
    });

    map<string, any> serviceDetails = $[];
    serviceDetails = (map<string, any>) Pkg::ServiceGet(service);

    // intelligently merge the repos_to_* flags (bnc#576532)
    list<string> currentToEnable  = (list<string>) serviceDetails["repos_to_enable"]:[];
    list<string> currentToDisable = (list<string>) serviceDetails["repos_to_disable"]:[];
    // remove duplicates
    currentToEnable  = toset(currentToEnable);
    currentToDisable = toset(currentToDisable);
    catalogToEnable  = toset(catalogToEnable);
    catalogToDisable = toset(catalogToDisable);
    y2debug("Current   repos_to_enable : %1", currentToEnable);
    y2debug("Current   repos_to_disable: %1", currentToDisable);
    y2debug("Requested repos_to_enable : %1", catalogToEnable);
    y2debug("Requested repos_to_disable: %1", catalogToDisable);

    list<string> newToEnable = [];
    list<string> newToDisable = [];

    // filter out "repos_to_enable" that are requested to be disabled (bnc#576532)
    newToEnable = filter(string oneCatalog, (list<string>) union(currentToEnable, catalogToEnable), {
        return ! contains(catalogToDisable, oneCatalog);
    });

    // filter out "repos_to_disable" that are requested to be enabled (bnc#576532)
    newToDisable = filter(string oneCatalog, (list<string>) union(currentToDisable, catalogToDisable), {
        return ! contains(catalogToEnable, oneCatalog);
    });

    y2debug("Resulting repos_to_enable : %1", newToEnable);
    y2debug("Resulting repos_to_disable: %1", newToDisable);
    serviceDetails["repos_to_enable"]  = newToEnable;
    serviceDetails["repos_to_disable"] = newToDisable;

    // enabled flag must not be present - otherwise all catalogs will be activated
    serviceDetails = remove(serviceDetails, "enabled");

    y2debug("Setting service properties for service (%1): %2", service, serviceDetails);

    if ( Pkg::ServiceSet(service, serviceDetails) )
    {
        y2milestone("Successfully updated the catalog settings of service: %1", service);
        y2milestone("Set repostoenable: %1 (%2)", catalogToEnable, service);
        y2milestone("Set repostodisable: %1 (%2)", catalogToDisable, service);
        // saving the service is (resp. has to be) done after calling checkCatalogs()
    }
    else
    {
        y2error("Could not update the catalog settings of service: %1", service);
        repoUpdateSuccessful = false;
    }

    return cSummary;
}





/*
 * updateSoftwareRepositories
 *
 * takes a "taskList"-map from SuseRegister and updates the repositories
 * @return a list with a small summary (added/deleted/enabled/disabled repos)
 */
global list<string> updateSoftwareRepositories(map<string, any> taskList, boolean doRefresh)
{
    // see if there are actions to perform
    if (taskList == $[])
    {
        return [];
    }

    y2debug("Task list to update software repositories: %1", taskList);

    list<string> summary = [];

    list<map> currentSources = Pkg::SourceEditGet();
    // log the sources for debugging purposes
    // y2milestone("The current sources are: %1", currentSources);


    // outer foreach loop - loop over service names/aliases
    foreach( string pService, any pAny, taskList, {

        if ( ! is(pAny, map) )
        {
            y2error("A service returned by SuseRegister did not contain any details: %1", pService);
            repoUpdateSuccessful = false;
        }
        else if ( pService == nil || pService == "" )
        {
            y2error("A service returned by SuseRegister has no or an invalid name.");
            repoUpdateSuccessful = false;
        }
        else
        {
            if ( ! is( ((map) pAny)["TYPE"]:"", string) )
            {
                y2error("A service returned by SuseRegister has an invalid type: %1 (%2)", pService, ((map) pAny)["TYPE"]:"");
                repoUpdateSuccessful = false;
            }
            if ( ((map) pAny)["TYPE"]:"" == "zypp" )
            {
                y2milestone("Handling a service of the type zypp");
                if ( ! is( ((map) pAny)["TASK"]:"", string) )
                {
                    y2error("A service returned by SuseRegister has an invalid task: %1 (%2)", pService, ((map) pAny)["TASK"]:"" );
                    repoUpdateSuccessful = false;
                }
                else if ( ((map) pAny)["TASK"]:"" == "le"  ||  ((map) pAny)["TASK"]:"" == "ld" )
                {
                    y2milestone("According to SuseRegister a service does not need to be changed: %1", pService);
                }
                else if ( ((map) pAny)["TASK"]:"" == "a" )
                {
                    // SourceAdd
                    y2milestone("According to SuseRegister a service has to be added: %1", pService);

                    // create map for new source
                    map<string, any> newSrcMap = $[  "enabled"       : true,
                                                     "autorefresh"   : true,
                                                     "name"          : (string) ((map) pAny)["NAME"]:"",
                                                     "alias"         : (string) ((map) pAny)["ALIAS"]:"",
                                                     "base_urls"     : [ (string) ((map) pAny)["URL"]:"" ],
                                                     "priority"      : ((map) pAny)["PRIORITY"]:99
                                                     // remove repo type (bnc#444770)
                                                 ];

                    integer newSrcID = Pkg::RepositoryAdd( newSrcMap );

                    if ( newSrcID == nil )
                    {
                        y2error("Adding a new service failed: %1", pService );
                        repoUpdateSuccessful = false;
                    }
                    else
                    {
                        y2milestone("Successfully added a new service: %1 (%2)", pService, newSrcID);
                        summary = add(summary, sformat(_("Added Source: %1"), pService ));
                    }

                }
                else if ( ((map) pAny)["TASK"]:"" == "d" )
                {
                    // SourceDelete
                    y2milestone("According to SuseRegister a service has to be deleted: %1", pService);

                    integer srcID = getSrcIdFromSrcList(pService, currentSources);
                    if ( srcID == nil )
                    {
                        y2error("A service that should be deleted can not be found: %1", pService);
                        repoUpdateSuccessful = false;
                    }
                    else
                    {
                        if ( Pkg::SourceDelete(srcID) )
                        {
                            y2milestone("Successfully deleted a service: %1 (%2)", pService, srcID);
                            summary = add(summary, sformat(_("Deleted Source: %1"), pService));
                        }
                        else
                        {
                            y2error("Could not delete a service: %1 (%2)", pService, srcID);
                            repoUpdateSuccessful = false;
                        }
                    }
                }
                else
                {
                    y2error("A service returned by SuseRegister has an unsupported task: %1 (%2)", pService, ((map) pAny)["TASK"]:"" );
                    repoUpdateSuccessful = false;
                }

            }
            else if ( ((map) pAny)["TYPE"]:"" == "nu" )
            {
                y2milestone("Handling a service of the type nu");

                if ( ! is( ((map) pAny)["TASK"]:"", string) )
                {
                    y2error("A service returned by SuseRegister has an invalid task: %1 (%2)", pService, ((map) pAny)["TASK"]:"" );
                    repoUpdateSuccessful = false;
                }
                else if ( ((map) pAny)["TASK"]:"" == "ld" )
                {
                    y2milestone("According to SuseRegister a service should be left disabled: %1", pService);
                }
                else if ( ((map) pAny)["TASK"]:"" == "le" )
                {
                    y2milestone("According to SuseRegister a service should be left enabled: %1", pService);
                    y2milestone("Now checking the catalogs of the service: %1", pService );

                    any catalogsMap = ((map) pAny)["CATALOGS"]:$[];
                    if ( is( catalogsMap , map)  &&  catalogsMap != $[] )
                    {
                        y2milestone("A service returned by SuseRegister has catalogs that will be checked now.");
                        list<string> cSummary = checkCatalogs( (map<string, any>) catalogsMap, pService );
                        summary = (list<string>) merge(summary, cSummary);
                    }
                    else
                    {
                        y2error("A service returned by SuseRegister did not contain any catalogs.");
                        repoUpdateSuccessful = false;
                    }

                    // we may have changed something - so lets save and refresh now
                    // because the Pkg bindings do not operate on the system directly we need to save them before we can continue
                    if ( Pkg::ServiceSave(pService) )
                    {
                        y2milestone("Successfully saved service: %1.", pService);

                        if ( Pkg::ServiceRefresh(pService) )
                        {
                            y2milestone("Successfully refreshed service: %1", pService);
                        }
                        else
                        {
                            y2error("Could not refresh service: %1", pService);
                        }
                    }
                    else
                    {
                        y2error("Could not save a service to the system: %1", pService);
                        repoUpdateSuccessful = false;
                    }

                }
                else if ( ((map) pAny)["TASK"]:"" == "a" )
                {
                    // ServiceAdd
                    y2milestone("According to SuseRegister a service has to be added: %1", pService);

                    // add credetials information (bnc#435645)
                    map serviceAddUrl = URL::Parse( ((map) pAny)["URL"]:"" );
                    string queryJoinChar = "";
                    if ( size( (string)serviceAddUrl["query"]:"" ) > 0 )
                    {
                        queryJoinChar = "&";
                    }
                    serviceAddUrl["query"] = (string) serviceAddUrl["query"]:"" + queryJoinChar + "credentials=NCCcredentials";

                    if ( Pkg::ServiceAdd( pService, URL::Build(serviceAddUrl) ) )
                    {
                        y2milestone("Successfully added a new service: %1", pService);
                        y2milestone("Now checking the catalogs of the service: %1", pService);
                        summary = add(summary, sformat(_("Added Service: %1"), pService ));

                        // activate autorefresh - only for services that get added!
                        map<string, any> newServiceDetails = Pkg::ServiceGet(pService);
                        newServiceDetails["autorefresh"] = true;
                        if ( Pkg::ServiceSet(pService, newServiceDetails) )
                        {
                            y2milestone("Successfully activated autofresh mode for service: %1", pService);
                        }
                        else
                        {
                            y2error("Could not activate autofresh mode for service: %1", pService);
                        }

                        // then iterate over catalogs
                        any catalogsMap = ((map) pAny)["CATALOGS"]:$[];
                        if ( is( catalogsMap , map)  &&  catalogsMap != $[] )
                        {
                            y2milestone("A new service returned by SuseRegister has catalogs that will be checked now.");
                            list<string> cSummary = checkCatalogs( (map<string, any>) catalogsMap, pService );
                            summary = (list<string>) merge(summary, cSummary);
                        }
                        else
                        {
                            y2error("A new service returned by SuseRegister did not contain any catalogs.");
                            repoUpdateSuccessful = false;
                        }

                        // we may have changed something - so lets save and refresh now
                        // because the Pkg bindings do not operate on the system directly we need to save them before we can continue
                        if ( Pkg::ServiceSave(pService) )
                        {
                            y2milestone("Successfully saved service: %1.", pService);

                            if ( Pkg::ServiceRefresh(pService) )
                            {
                                y2milestone("Successfully refreshed service: %1", pService);
                            }
                            else
                            {
                                y2error("Could not refresh service: %1", pService);
                            }
                        }
                        else
                        {
                            y2error("Could not save a service to the system: %1", pService);
                            repoUpdateSuccessful = false;
                        }
                    }
                    else
                    {
                        y2error("Adding a new service failed: %1", pService);
                        repoUpdateSuccessful = false;
                    }

                }
                else if ( ((map) pAny)["TASK"]:"" == "d" )
                {
                    // ServiceDelete
                    y2milestone("According to SuseRegister a service has to be deleted: %1", pService);

                    if ( Pkg::ServiceDelete(pService) )
                    {
                        y2milestone("Successfully deleted a service: %1", pService);
                        summary = add(summary, sformat(_("Deleted Service: %1"), pService ));
                    }
                    else
                    {
                        y2error("Could not delete a service: %1", pService);
                        repoUpdateSuccessful = false;
                    }
                }
                else
                {
                    y2error("A service returned by SuseRegister has an unsupported task: %1 (%2)", pService, ((map) pAny)["TASK"]:"" );
                    repoUpdateSuccessful = false;
                }
            }
            else
            {
                y2error("A service returned by SuseRegister has an unsupported type: %1 (%2)", pService, ((map) pAny)["TYPE"]:"" );
                repoUpdateSuccessful = false;
            }

        }
    });


    // save all changes to the sources that we have done
    Pkg::SourceSaveAll();

    // finish sources (bnc#447080)

    if ( Pkg::SourceFinishAll() )
    {
        y2milestone("Successfully finished all sources.");
        // we can not refresh in autoYaST mode as it may require manual interaction to import keys
        if ( doRefresh )
        {
            y2milestone("Enforce a reload.");

            // restart the SourceManager to refill the cache with the current data (bnc#468449 bnc#572634)
            // an application that called the registration (or that follows it) should be presented an updated pkg system
            if ( Pkg::SourceStartManager(true) )
            {
                y2milestone("Successfully restarted source manager.");
            }
            else
            {
                y2error("Failed to restart source manager");
            }
        }
    }
    else
    {
        y2error("Failed to finish all sources.");
    }

    if ( repoUpdateSuccessful )
    {
        y2milestone("SuseRegister will now save the lastZmdConfig.");
        YSR::saveLastZmdConfig();
    }
    else
    {
        y2error("Error occurred while changing the systems repositories according to the instructions of SuseRegister. SuseRegister will not save this status as lastZmdConfig.");
    }


    return summary;
}


/*
 * suseRegister()
 * return the error code of SuseRegister (via YSR.pm) as integer
*/
global integer suseRegister(symbol parameter)
{
    list<integer> allCurrentSources = [];
    list<string> allCurrentServices = [];

    map ui = UI::GetDisplayInfo();
    boolean debugMode = (boolean) ui["y2debug"]:false;

    // take care for nil booleans (bnc#463800)
    map<string, any> contextData = $[
                                        "debug"             :  (debugMode          == true ? 2:0),
                                        "nooptional"        :  (submit_optional    == true ? 0:1),
                                        "nohwdata"          :  (submit_hwdata      == true ? 0:1),
                                        "forcereg"          :  (force_registration == true ? 1:0),  // (bnc#443704)
                                        "norefresh"         :  1,
                                        "yastcall"          :  1,
                                        "restoreRepos"      :  1,                          // (#309231)
                                        "logfile"           :  "/root/.suse_register.log"
                                    ];

    // workaround for (bnc#490811)
    string yastLocale = getenv("LANG");
    y2milestone("Locale before suseRegister run: %1", yastLocale);
    if ( yastLocale != nil  &&  yastLocale != "" )
    {
        contextData["locale"] = yastLocale;
    }

    y2milestone("Basic initialization data for SuseRegister (custom registration data is suppressed for security reasons): %1", contextData);

    // add data to the context from autoyast profile or from manual input
    if ( registration_data != $[] )
    {
        // append sensitive data to the context map
        contextData["args"] = registration_data;
        // do not log sensitive data to the log (#195624)
        y2milestone ("Added sensitive registration data to suse_register call - this data is not logged");
    }


    if ( ! isInitializedSR  ||  ! isInitializedTarget || contextData != contextDataSR )
    {
        // initialize target
        if ( ! isInitializedTarget )
        {
            string targetRootDir = Mode::normal() == true ? "/":Installation::destdir;
            if ( ! Pkg::TargetInitialize(targetRootDir) )
            {
                y2error("Initializing the target failed via Pkg::TargetInitialize. No interaction with the package system is possible.");
                return 113;
            }
            y2milestone("Successfully initialized the target.");
            isInitializedTarget = true;
        }

        // always restart the source manager (bnc#576532)
        if ( Pkg::SourceStartManager(true) )
        {
            y2milestone("Successfully started source manager.");
        }
        else
        {
            y2error("Failed to start source manager");
            return 199;
        }

        y2milestone("Initially refreshing services.");
        // refresh all services _once_ before interacting with SuseRegister
        allCurrentServices = Pkg::ServiceAliases();

        foreach ( string serviceAlias, allCurrentServices, {
            y2milestone("Refreshing service with Alias: %1", serviceAlias);
            Pkg::ServiceRefresh(serviceAlias);
        });

        y2milestone("Initially refreshing sources.");
        // refresh all sources _once_ before interacting with SuseRegister
        allCurrentSources = Pkg::SourceGetCurrent(true);

        foreach ( integer srcID, allCurrentSources, {
            y2milestone("Refreshing source with ID: %1", srcID);
            // no "forced" refresh needed - default is sufficient (bnc#476429)
            Pkg::SourceRefreshNow(srcID);
        });
        y2milestone("Initial refreshing ended.");

        // setting the proxy must happen before init_ctx is called (bnc#468480)
        // setting up proxy for SuseRegister
        if (Register::use_proxy)
        {
            // setup proxy for http and https individually (bnc#468919)
            if (Register::http_proxy  == nil)
            {
                Register::http_proxy = "";
                y2error("Setting for http proxy is broken. Resetting http proxy. Registration will not use an http proxy.");
            }

            if (Register::https_proxy  == nil)
            {
                Register::https_proxy = "";
                y2error("Setting for https proxy is broken. Resetting https proxy. Registration will not use an https proxy.");
            }

            if (Register::http_proxy  != "" ||  Register::https_proxy != "")
            {
                y2milestone("Setting up proxy for SuseRegister. http_proxy: %1  -- https_proxy: %2", Register::http_proxy, Register::https_proxy);
                YSR::set_proxy(Register::http_proxy, Register::https_proxy);
            }
            else
            {
                y2milestone("No proxy settings will be used for registration and SuseRegister.");
            }
        }

        // initialize SuseRegister
        contextDataSR = contextData;
        y2milestone("Initializing SuseRegister with this context data: %1", contextDataSR);
        YSR::init_ctx(contextDataSR);

        integer initErrorCode = YSR::get_errorcode();
        if ( initErrorCode == 0 )
        {
            y2milestone("Successfully initialized SuseRegister.");
            isInitializedSR = true;
        }
        else
        {
            y2error("Initializing SuseRegister failed with error code (%1) and error message: %2", initErrorCode, YSR::get_errormsg());
            return initErrorCode;
        }
    }

    // ----====  handle modes for suseRegister  ====----

    // special mode for list-params
    // only makes sure registration is initialized
    if (parameter == `listparams)
    {
        y2milestone("Making sure suseregister is initialized for listparams");
        return 0;
    }


    // registration loop - has to loop until return code gets != 1
    do
    {
        initialSRstatus = suseRegisterOnce();
        y2milestone("SuseRegister loop: SuseRegister returned with error code: %1", initialSRstatus );
    } while ( initialSRstatus == 1 );


    // everything fine - nothing to be done
    if ( initialSRstatus == 0 )
    {
        y2milestone("SuseRegister returned with status: %1", initialSRstatus);
        // touch webyast flag file to show in webyast that this machine is already registered (bnc#634026)
        SCR::Execute(.target.bash, " [ -d  /var/lib/yastws ]       && date +%s > /var/lib/yastws/registration_successful " );
        SCR::Execute(.target.bash, " [ -d  /var/lib/suseRegister ] && date +%s > /var/lib/suseRegister/y2_registration_successful " );
    }


    if ( parameter == `autoyast )
    {
        y2milestone("SuseRegister was called in autoYaST mode. The overall registration satus is: %1", initialSRstatus);
        if ( initialSRstatus == 0 )
        {
            y2milestone("Registeration in autoYaST mode succeeded. Now checking the repositories.");
            // in autoyast mode this must be called from here
            map<string, any> taskList = YSR::getTaskList();
            if ( taskList == $[] )
            {
                y2milestone("According to SuseRegister no repositories need to be changed.");
            }
            else
            {
                updateSoftwareRepositories(taskList, false);
            }
        }
        else if ( initialSRstatus == 4 )
        {
            y2error("Manual interaction is required for proper registration which is not possible during autoYaST. Please register manually.");
        }

    }

    y2milestone("SuseRegister status: %1", initialSRstatus);
    return initialSRstatus;
}


/*
 * suseRegisterListParams()
 * returns the text to display as details in the registration module
*/
global string suseRegisterListParams()
{
    y2milestone("User requested the args map. Collecting registration data details.");

    // make sure the suseRegister is initialized and the args map contains information
    integer retval = suseRegister(`listparams);
    if (retval == 0)
    {
        y2milestone("Registration data details map: %1", argsDataSR);
        return YSR::listParams();
    }

    y2error("Error occurred when collecting registration data details. The exit code was: %1", retval);
    return _("Error: Could not retrieve data.");
}



// ------------------------------------------------------------------
// END: Globally defined functions
// ------------------------------------------------------------------



/*
 * Read()
 */
global void Read()
{
    initialize();
}


/*
 * Import()
 */
global boolean Import(map settings)
{
    iamroot = amIroot();

    submit_optional = false;
    submit_hwdata   = false;
    do_registration = false;
    registration_data = $[];

    submit_optional     = (boolean) settings["submit_optional"]:submit_optional;
    submit_hwdata       = (boolean) settings["submit_hwdata"]:submit_hwdata;
    do_registration     = (boolean) settings["do_registration"]:do_registration;
    register_regularly  = (boolean) settings["register_regularly"]:register_regularly;
    registration_data   = (map<string, string>) settings["registration_data"]:$[];
    smt_server          = (string) settings["reg_server"]:"";
    smt_server_cert     = (string) settings["reg_server_cert"]:"";

    return true;
}



/*
 * Write()
 */
global boolean Write()
{
    iamroot = amIroot();
    setupRegistrationServer(`autoyast);
    if (do_registration) suseRegister(`autoyast);
    finish();
    return true;
}



/**
 * AutoYaST interface function: Export()
 * @return map with the settings
 */
global map Export()
{
    return $[
               "submit_optional":submit_optional,
               "submit_hwdata":submit_hwdata,
               "do_registration":do_registration,
               "register_regularly":register_regularly,
               "reg_server":smt_server,
               "reg_server_cert":smt_server_cert,
               "registration_data":registration_data
    ];
}

} // -EOF-
